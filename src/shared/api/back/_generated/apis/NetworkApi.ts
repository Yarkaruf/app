/* tslint:disable */
/* eslint-disable */
/**
 * Medialand API
 * Medialand API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import useSWR, { ConfigInterface } from "swr";

import {
  BuyIp,
  BuyIpFromJSON,
  BuyIpToJSON,
  IP,
  IPFromJSON,
  IPToJSON,
  IpAssign,
  IpAssignFromJSON,
  IpAssignToJSON,
  IpInvoiceId,
  IpInvoiceIdFromJSON,
  IpInvoiceIdToJSON,
  SetReverseDns,
  SetReverseDnsFromJSON,
  SetReverseDnsToJSON
} from "../models";

interface IpAssignRequest {
  id: string;
  ipAssign: IpAssign;
}

interface IpBuyRequest {
  buyIp: BuyIp;
}

interface IpDeassignRequest {
  id: string;
}

interface IpDeleteRequest {
  id: string;
}

interface IpListRequest {
  assignmentId?: string;
  assignmentType?: string;
  dataCenterName?: string;
  assigned?: string;
}

interface IpSetReverseDnsRequest {
  id: string;
  setReverseDns: SetReverseDns;
}

/**
 *
 */
export class NetworkApi extends runtime.BaseAPI {
  /**
   */
  private async ipAssignRaw(requestParameters: IpAssignRequest): Promise<runtime.ApiResponse<void>> {
    this.ipAssignValidation(requestParameters);
    const context = this.ipAssignContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private ipAssignValidation(requestParameters: IpAssignRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling ipAssign."
      );
    }
    if (requestParameters.ipAssign === null || requestParameters.ipAssign === undefined) {
      throw new runtime.RequiredError(
        "ipAssign",
        "Required parameter requestParameters.ipAssign was null or undefined when calling ipAssign."
      );
    }
  }

  /**
   */
  private ipAssignContext(requestParameters: IpAssignRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/network/ip/{id}/assign`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: IpAssignToJSON(requestParameters.ipAssign)
    };
  }

  /**
   */
  ipAssign = async (id: string, ipAssign: IpAssign): Promise<void> => {
    await this.ipAssignRaw({ id: id, ipAssign: ipAssign });
  };

  /**
   */
  private async ipBuyRaw(requestParameters: IpBuyRequest): Promise<runtime.ApiResponse<IpInvoiceId>> {
    this.ipBuyValidation(requestParameters);
    const context = this.ipBuyContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => IpInvoiceIdFromJSON(jsonValue));
  }

  /**
   */
  private ipBuyValidation(requestParameters: IpBuyRequest) {
    if (requestParameters.buyIp === null || requestParameters.buyIp === undefined) {
      throw new runtime.RequiredError(
        "buyIp",
        "Required parameter requestParameters.buyIp was null or undefined when calling ipBuy."
      );
    }
  }

  /**
   */
  private ipBuyContext(requestParameters: IpBuyRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/network/ip`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: BuyIpToJSON(requestParameters.buyIp)
    };
  }

  /**
   */
  ipBuy = async (buyIp: BuyIp): Promise<IpInvoiceId> => {
    const response = await this.ipBuyRaw({ buyIp: buyIp });
    return await response.value();
  };

  /**
   */
  private async ipDeassignRaw(requestParameters: IpDeassignRequest): Promise<runtime.ApiResponse<void>> {
    this.ipDeassignValidation(requestParameters);
    const context = this.ipDeassignContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private ipDeassignValidation(requestParameters: IpDeassignRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling ipDeassign."
      );
    }
  }

  /**
   */
  private ipDeassignContext(requestParameters: IpDeassignRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/network/ip/{id}/deassign`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  ipDeassign = async (id: string): Promise<void> => {
    await this.ipDeassignRaw({ id: id });
  };

  /**
   */
  private async ipDeleteRaw(requestParameters: IpDeleteRequest): Promise<runtime.ApiResponse<IpInvoiceId>> {
    this.ipDeleteValidation(requestParameters);
    const context = this.ipDeleteContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => IpInvoiceIdFromJSON(jsonValue));
  }

  /**
   */
  private ipDeleteValidation(requestParameters: IpDeleteRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling ipDelete."
      );
    }
  }

  /**
   */
  private ipDeleteContext(requestParameters: IpDeleteRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/network/ip/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  ipDelete = async (id: string): Promise<IpInvoiceId> => {
    const response = await this.ipDeleteRaw({ id: id });
    return await response.value();
  };

  useIpDelete(id: string, config?: ConfigInterface<IpInvoiceId, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.ipDeleteContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.ipDelete(id!) : undefined, config);
  }

  /**
   */
  private async ipListRaw(requestParameters: IpListRequest): Promise<runtime.ApiResponse<Array<IP>>> {
    this.ipListValidation(requestParameters);
    const context = this.ipListContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(IPFromJSON));
  }

  /**
   */
  private ipListValidation(requestParameters: IpListRequest) {}

  /**
   */
  private ipListContext(requestParameters: IpListRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.assignmentId !== undefined) {
      queryParameters["assignmentId"] = requestParameters.assignmentId;
    }

    if (requestParameters.assignmentType !== undefined) {
      queryParameters["assignmentType"] = requestParameters.assignmentType;
    }

    if (requestParameters.dataCenterName !== undefined) {
      queryParameters["dataCenterName"] = requestParameters.dataCenterName;
    }

    if (requestParameters.assigned !== undefined) {
      queryParameters["assigned"] = requestParameters.assigned;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/network/ip`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  ipList = async (
    assignmentId?: string,
    assignmentType?: string,
    dataCenterName?: string,
    assigned?: string
  ): Promise<Array<IP>> => {
    const response = await this.ipListRaw({
      assignmentId: assignmentId,
      assignmentType: assignmentType,
      dataCenterName: dataCenterName,
      assigned: assigned
    });
    return await response.value();
  };

  useIpList(
    assignmentId?: string,
    assignmentType?: string,
    dataCenterName?: string,
    assigned?: string,
    config?: ConfigInterface<Array<IP>, Error>
  ) {
    let valid = true;

    const context = this.ipListContext({
      assignmentId: assignmentId!,
      assignmentType: assignmentType!,
      dataCenterName: dataCenterName!,
      assigned: assigned!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.ipList(assignmentId!, assignmentType!, dataCenterName!, assigned!) : undefined,
      config
    );
  }

  /**
   */
  private async ipSetReverseDnsRaw(requestParameters: IpSetReverseDnsRequest): Promise<runtime.ApiResponse<void>> {
    this.ipSetReverseDnsValidation(requestParameters);
    const context = this.ipSetReverseDnsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private ipSetReverseDnsValidation(requestParameters: IpSetReverseDnsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling ipSetReverseDns."
      );
    }
    if (requestParameters.setReverseDns === null || requestParameters.setReverseDns === undefined) {
      throw new runtime.RequiredError(
        "setReverseDns",
        "Required parameter requestParameters.setReverseDns was null or undefined when calling ipSetReverseDns."
      );
    }
  }

  /**
   */
  private ipSetReverseDnsContext(requestParameters: IpSetReverseDnsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/network/ip/{id}/reverse-dns`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: SetReverseDnsToJSON(requestParameters.setReverseDns)
    };
  }

  /**
   */
  ipSetReverseDns = async (id: string, setReverseDns: SetReverseDns): Promise<void> => {
    await this.ipSetReverseDnsRaw({ id: id, setReverseDns: setReverseDns });
  };
}
