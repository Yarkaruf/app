/* tslint:disable */
/* eslint-disable */
/**
 * Medialand API
 * Medialand API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import useSWR, { ConfigInterface } from "swr";

import {
  BalanceDTO,
  BalanceDTOFromJSON,
  BalanceDTOToJSON,
  BalancePayment,
  BalancePaymentFromJSON,
  BalancePaymentToJSON,
  BalanceTransactionDTO,
  BalanceTransactionDTOFromJSON,
  BalanceTransactionDTOToJSON,
  BitcoinPayment,
  BitcoinPaymentFromJSON,
  BitcoinPaymentToJSON,
  BitcoinPaymentRate,
  BitcoinPaymentRateFromJSON,
  BitcoinPaymentRateToJSON,
  Card,
  CardFromJSON,
  CardToJSON,
  CheckoutSession,
  CheckoutSessionFromJSON,
  CheckoutSessionToJSON,
  CheckoutSessionCreateDTO,
  CheckoutSessionCreateDTOFromJSON,
  CheckoutSessionCreateDTOToJSON,
  ChoosePaymentSystem,
  ChoosePaymentSystemFromJSON,
  ChoosePaymentSystemToJSON,
  CreateDepositRequest,
  CreateDepositRequestFromJSON,
  CreateDepositRequestToJSON,
  Deposit,
  DepositFromJSON,
  DepositToJSON,
  DepositConfig,
  DepositConfigFromJSON,
  DepositConfigToJSON,
  Discount,
  DiscountFromJSON,
  DiscountToJSON,
  FinanceHistoryEntry,
  FinanceHistoryEntryFromJSON,
  FinanceHistoryEntryToJSON,
  Invoice,
  InvoiceFromJSON,
  InvoiceToJSON,
  ModulbankPayment,
  ModulbankPaymentFromJSON,
  ModulbankPaymentToJSON,
  Payment,
  PaymentFromJSON,
  PaymentToJSON,
  PaymentAttempt,
  PaymentAttemptFromJSON,
  PaymentAttemptToJSON,
  PaypalPayment,
  PaypalPaymentFromJSON,
  PaypalPaymentToJSON,
  Rate,
  RateFromJSON,
  RateToJSON,
  StripeCardClientSecret,
  StripeCardClientSecretFromJSON,
  StripeCardClientSecretToJSON,
  StripePayment,
  StripePaymentFromJSON,
  StripePaymentToJSON,
  Subscription,
  SubscriptionFromJSON,
  SubscriptionToJSON,
  SubscriptionInvoiceId,
  SubscriptionInvoiceIdFromJSON,
  SubscriptionInvoiceIdToJSON,
  SubscriptionSwitchToMonthly,
  SubscriptionSwitchToMonthlyFromJSON,
  SubscriptionSwitchToMonthlyToJSON
} from "../models";

interface BitcoinPaymentParamsRequest {
  id: string;
}

interface CancelCheckoutSessionRequest {
  id: string;
}

interface CheckoutSessionRequest {
  id: string;
}

interface ChoosePaymentSystemRequest {
  id: string;
  choosePaymentSystem: ChoosePaymentSystem;
}

interface ConfirmCheckoutSessionRequest {
  id: string;
}

interface CorePaymentParamsRequest {
  id: string;
}

interface CreateCheckoutSessionRequest {
  checkoutSessionCreateDTO: CheckoutSessionCreateDTO;
}

interface CreateDepositOperationRequest {
  createDepositRequest: CreateDepositRequest;
}

interface DeleteCardRequest {
  id: string;
}

interface DepositRequest {
  id: string;
}

interface InvoiceRequest {
  id: string;
}

interface InvoiceCancelRequest {
  id: string;
}

interface ModulbankPaymentParamsRequest {
  id: string;
}

interface PaymentParamsRequest {
  id: string;
}

interface PaypalPaymentParamsRequest {
  id: string;
}

interface StripePaymentParamsRequest {
  id: string;
}

interface SubscriptionRequest {
  id: string;
}

interface SubscriptionProlongRequest {
  id: string;
  subscriptionSwitchToMonthly: SubscriptionSwitchToMonthly;
}

interface SubscriptionSwitchToHourlyRequest {
  id: string;
}

interface SubscriptionSwitchToMonthlyRequest {
  id: string;
  subscriptionSwitchToMonthly: SubscriptionSwitchToMonthly;
}

/**
 *
 */
export class BillingApi extends runtime.BaseAPI {
  /**
   */
  private async addModulbankCardRaw(): Promise<runtime.ApiResponse<object>> {
    this.addModulbankCardValidation();
    const context = this.addModulbankCardContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private addModulbankCardValidation() {}

  /**
   */
  private addModulbankCardContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/card/modulbank`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  addModulbankCard = async (): Promise<object> => {
    const response = await this.addModulbankCardRaw();
    return await response.value();
  };

  /**
   */
  private async addStripeCardRaw(): Promise<runtime.ApiResponse<StripeCardClientSecret>> {
    this.addStripeCardValidation();
    const context = this.addStripeCardContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => StripeCardClientSecretFromJSON(jsonValue));
  }

  /**
   */
  private addStripeCardValidation() {}

  /**
   */
  private addStripeCardContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/card/stripe`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  addStripeCard = async (): Promise<StripeCardClientSecret> => {
    const response = await this.addStripeCardRaw();
    return await response.value();
  };

  /**
   */
  private async bitcoinPaymentParamsRaw(
    requestParameters: BitcoinPaymentParamsRequest
  ): Promise<runtime.ApiResponse<BitcoinPayment>> {
    this.bitcoinPaymentParamsValidation(requestParameters);
    const context = this.bitcoinPaymentParamsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => BitcoinPaymentFromJSON(jsonValue));
  }

  /**
   */
  private bitcoinPaymentParamsValidation(requestParameters: BitcoinPaymentParamsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling bitcoinPaymentParams."
      );
    }
  }

  /**
   */
  private bitcoinPaymentParamsContext(requestParameters: BitcoinPaymentParamsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/payment/bitcoin/{id}/payment-params`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  bitcoinPaymentParams = async (id: string): Promise<BitcoinPayment> => {
    const response = await this.bitcoinPaymentParamsRaw({ id: id });
    return await response.value();
  };

  useBitcoinPaymentParams(id: string, config?: ConfigInterface<BitcoinPayment, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.bitcoinPaymentParamsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.bitcoinPaymentParams(id!) : undefined, config);
  }

  /**
   */
  private async bitcoinPaymentRateRaw(): Promise<runtime.ApiResponse<BitcoinPaymentRate>> {
    this.bitcoinPaymentRateValidation();
    const context = this.bitcoinPaymentRateContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => BitcoinPaymentRateFromJSON(jsonValue));
  }

  /**
   */
  private bitcoinPaymentRateValidation() {}

  /**
   */
  private bitcoinPaymentRateContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/api/billing/payment/bitcoin/rate`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  bitcoinPaymentRate = async (): Promise<BitcoinPaymentRate> => {
    const response = await this.bitcoinPaymentRateRaw();
    return await response.value();
  };

  useBitcoinPaymentRate(config?: ConfigInterface<BitcoinPaymentRate, Error>) {
    let valid = true;

    const context = this.bitcoinPaymentRateContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.bitcoinPaymentRate() : undefined, config);
  }

  /**
   */
  private async cancelCheckoutSessionRaw(
    requestParameters: CancelCheckoutSessionRequest
  ): Promise<runtime.ApiResponse<CheckoutSession>> {
    this.cancelCheckoutSessionValidation(requestParameters);
    const context = this.cancelCheckoutSessionContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => CheckoutSessionFromJSON(jsonValue));
  }

  /**
   */
  private cancelCheckoutSessionValidation(requestParameters: CancelCheckoutSessionRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling cancelCheckoutSession."
      );
    }
  }

  /**
   */
  private cancelCheckoutSessionContext(requestParameters: CancelCheckoutSessionRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/checkout/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  cancelCheckoutSession = async (id: string): Promise<CheckoutSession> => {
    const response = await this.cancelCheckoutSessionRaw({ id: id });
    return await response.value();
  };

  /**
   */
  private async cardsRaw(): Promise<runtime.ApiResponse<Array<Card>>> {
    this.cardsValidation();
    const context = this.cardsContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(CardFromJSON));
  }

  /**
   */
  private cardsValidation() {}

  /**
   */
  private cardsContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/card`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  cards = async (): Promise<Array<Card>> => {
    const response = await this.cardsRaw();
    return await response.value();
  };

  useCards(config?: ConfigInterface<Array<Card>, Error>) {
    let valid = true;

    const context = this.cardsContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.cards() : undefined, config);
  }

  /**
   */
  private async checkoutSessionRaw(
    requestParameters: CheckoutSessionRequest
  ): Promise<runtime.ApiResponse<CheckoutSession>> {
    this.checkoutSessionValidation(requestParameters);
    const context = this.checkoutSessionContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => CheckoutSessionFromJSON(jsonValue));
  }

  /**
   */
  private checkoutSessionValidation(requestParameters: CheckoutSessionRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling checkoutSession."
      );
    }
  }

  /**
   */
  private checkoutSessionContext(requestParameters: CheckoutSessionRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/checkout/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  checkoutSession = async (id: string): Promise<CheckoutSession> => {
    const response = await this.checkoutSessionRaw({ id: id });
    return await response.value();
  };

  useCheckoutSession(id: string, config?: ConfigInterface<CheckoutSession, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.checkoutSessionContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.checkoutSession(id!) : undefined, config);
  }

  /**
   */
  private async choosePaymentSystemRaw(
    requestParameters: ChoosePaymentSystemRequest
  ): Promise<runtime.ApiResponse<PaymentAttempt>> {
    this.choosePaymentSystemValidation(requestParameters);
    const context = this.choosePaymentSystemContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PaymentAttemptFromJSON(jsonValue));
  }

  /**
   */
  private choosePaymentSystemValidation(requestParameters: ChoosePaymentSystemRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling choosePaymentSystem."
      );
    }
    if (requestParameters.choosePaymentSystem === null || requestParameters.choosePaymentSystem === undefined) {
      throw new runtime.RequiredError(
        "choosePaymentSystem",
        "Required parameter requestParameters.choosePaymentSystem was null or undefined when calling choosePaymentSystem."
      );
    }
  }

  /**
   */
  private choosePaymentSystemContext(requestParameters: ChoosePaymentSystemRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/payment/core/{id}/choose-payment-system`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ChoosePaymentSystemToJSON(requestParameters.choosePaymentSystem)
    };
  }

  /**
   */
  choosePaymentSystem = async (id: string, choosePaymentSystem: ChoosePaymentSystem): Promise<PaymentAttempt> => {
    const response = await this.choosePaymentSystemRaw({ id: id, choosePaymentSystem: choosePaymentSystem });
    return await response.value();
  };

  /**
   */
  private async confirmCheckoutSessionRaw(
    requestParameters: ConfirmCheckoutSessionRequest
  ): Promise<runtime.ApiResponse<CheckoutSession>> {
    this.confirmCheckoutSessionValidation(requestParameters);
    const context = this.confirmCheckoutSessionContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => CheckoutSessionFromJSON(jsonValue));
  }

  /**
   */
  private confirmCheckoutSessionValidation(requestParameters: ConfirmCheckoutSessionRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling confirmCheckoutSession."
      );
    }
  }

  /**
   */
  private confirmCheckoutSessionContext(requestParameters: ConfirmCheckoutSessionRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/checkout/{id}/confirm`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  confirmCheckoutSession = async (id: string): Promise<CheckoutSession> => {
    const response = await this.confirmCheckoutSessionRaw({ id: id });
    return await response.value();
  };

  /**
   */
  private async corePaymentParamsRaw(
    requestParameters: CorePaymentParamsRequest
  ): Promise<runtime.ApiResponse<Payment>> {
    this.corePaymentParamsValidation(requestParameters);
    const context = this.corePaymentParamsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PaymentFromJSON(jsonValue));
  }

  /**
   */
  private corePaymentParamsValidation(requestParameters: CorePaymentParamsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling corePaymentParams."
      );
    }
  }

  /**
   */
  private corePaymentParamsContext(requestParameters: CorePaymentParamsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/payment/core/{id}/payment-params`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  corePaymentParams = async (id: string): Promise<Payment> => {
    const response = await this.corePaymentParamsRaw({ id: id });
    return await response.value();
  };

  useCorePaymentParams(id: string, config?: ConfigInterface<Payment, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.corePaymentParamsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.corePaymentParams(id!) : undefined, config);
  }

  /**
   */
  private async createCheckoutSessionRaw(
    requestParameters: CreateCheckoutSessionRequest
  ): Promise<runtime.ApiResponse<CheckoutSession>> {
    this.createCheckoutSessionValidation(requestParameters);
    const context = this.createCheckoutSessionContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => CheckoutSessionFromJSON(jsonValue));
  }

  /**
   */
  private createCheckoutSessionValidation(requestParameters: CreateCheckoutSessionRequest) {
    if (
      requestParameters.checkoutSessionCreateDTO === null ||
      requestParameters.checkoutSessionCreateDTO === undefined
    ) {
      throw new runtime.RequiredError(
        "checkoutSessionCreateDTO",
        "Required parameter requestParameters.checkoutSessionCreateDTO was null or undefined when calling createCheckoutSession."
      );
    }
  }

  /**
   */
  private createCheckoutSessionContext(requestParameters: CreateCheckoutSessionRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/checkout`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CheckoutSessionCreateDTOToJSON(requestParameters.checkoutSessionCreateDTO)
    };
  }

  /**
   */
  createCheckoutSession = async (checkoutSessionCreateDTO: CheckoutSessionCreateDTO): Promise<CheckoutSession> => {
    const response = await this.createCheckoutSessionRaw({ checkoutSessionCreateDTO: checkoutSessionCreateDTO });
    return await response.value();
  };

  /**
   */
  private async createDepositRaw(
    requestParameters: CreateDepositOperationRequest
  ): Promise<runtime.ApiResponse<Deposit>> {
    this.createDepositValidation(requestParameters);
    const context = this.createDepositContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => DepositFromJSON(jsonValue));
  }

  /**
   */
  private createDepositValidation(requestParameters: CreateDepositOperationRequest) {
    if (requestParameters.createDepositRequest === null || requestParameters.createDepositRequest === undefined) {
      throw new runtime.RequiredError(
        "createDepositRequest",
        "Required parameter requestParameters.createDepositRequest was null or undefined when calling createDeposit."
      );
    }
  }

  /**
   */
  private createDepositContext(requestParameters: CreateDepositOperationRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/deposit`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateDepositRequestToJSON(requestParameters.createDepositRequest)
    };
  }

  /**
   */
  createDeposit = async (createDepositRequest: CreateDepositRequest): Promise<Deposit> => {
    const response = await this.createDepositRaw({ createDepositRequest: createDepositRequest });
    return await response.value();
  };

  /**
   */
  private async currencyRateRaw(): Promise<runtime.ApiResponse<Rate>> {
    this.currencyRateValidation();
    const context = this.currencyRateContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => RateFromJSON(jsonValue));
  }

  /**
   */
  private currencyRateValidation() {}

  /**
   */
  private currencyRateContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/api/billing/currency-rate`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  currencyRate = async (): Promise<Rate> => {
    const response = await this.currencyRateRaw();
    return await response.value();
  };

  useCurrencyRate(config?: ConfigInterface<Rate, Error>) {
    let valid = true;

    const context = this.currencyRateContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.currencyRate() : undefined, config);
  }

  /**
   */
  private async deleteCardRaw(requestParameters: DeleteCardRequest): Promise<runtime.ApiResponse<void>> {
    this.deleteCardValidation(requestParameters);
    const context = this.deleteCardContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private deleteCardValidation(requestParameters: DeleteCardRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteCard."
      );
    }
  }

  /**
   */
  private deleteCardContext(requestParameters: DeleteCardRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/card/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  deleteCard = async (id: string): Promise<void> => {
    await this.deleteCardRaw({ id: id });
  };

  useDeleteCard(id: string, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.deleteCardContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.deleteCard(id!) : undefined, config);
  }

  /**
   */
  private async depositRaw(requestParameters: DepositRequest): Promise<runtime.ApiResponse<Deposit>> {
    this.depositValidation(requestParameters);
    const context = this.depositContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => DepositFromJSON(jsonValue));
  }

  /**
   */
  private depositValidation(requestParameters: DepositRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deposit."
      );
    }
  }

  /**
   */
  private depositContext(requestParameters: DepositRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/deposit/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  deposit = async (id: string): Promise<Deposit> => {
    const response = await this.depositRaw({ id: id });
    return await response.value();
  };

  useDeposit(id: string, config?: ConfigInterface<Deposit, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.depositContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.deposit(id!) : undefined, config);
  }

  /**
   */
  private async depositConfigRaw(): Promise<runtime.ApiResponse<DepositConfig>> {
    this.depositConfigValidation();
    const context = this.depositConfigContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => DepositConfigFromJSON(jsonValue));
  }

  /**
   */
  private depositConfigValidation() {}

  /**
   */
  private depositConfigContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/deposit`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  depositConfig = async (): Promise<DepositConfig> => {
    const response = await this.depositConfigRaw();
    return await response.value();
  };

  useDepositConfig(config?: ConfigInterface<DepositConfig, Error>) {
    let valid = true;

    const context = this.depositConfigContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.depositConfig() : undefined, config);
  }

  /**
   */
  private async financeHistoryRaw(): Promise<runtime.ApiResponse<Array<FinanceHistoryEntry>>> {
    this.financeHistoryValidation();
    const context = this.financeHistoryContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(FinanceHistoryEntryFromJSON));
  }

  /**
   */
  private financeHistoryValidation() {}

  /**
   */
  private financeHistoryContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/user/finance-history`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  financeHistory = async (): Promise<Array<FinanceHistoryEntry>> => {
    const response = await this.financeHistoryRaw();
    return await response.value();
  };

  useFinanceHistory(config?: ConfigInterface<Array<FinanceHistoryEntry>, Error>) {
    let valid = true;

    const context = this.financeHistoryContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.financeHistory() : undefined, config);
  }

  /**
   */
  private async invoiceRaw(requestParameters: InvoiceRequest): Promise<runtime.ApiResponse<Invoice>> {
    this.invoiceValidation(requestParameters);
    const context = this.invoiceContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => InvoiceFromJSON(jsonValue));
  }

  /**
   */
  private invoiceValidation(requestParameters: InvoiceRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling invoice."
      );
    }
  }

  /**
   */
  private invoiceContext(requestParameters: InvoiceRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/invoice/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  invoice = async (id: string): Promise<Invoice> => {
    const response = await this.invoiceRaw({ id: id });
    return await response.value();
  };

  useInvoice(id: string, config?: ConfigInterface<Invoice, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.invoiceContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.invoice(id!) : undefined, config);
  }

  /**
   */
  private async invoiceCancelRaw(requestParameters: InvoiceCancelRequest): Promise<runtime.ApiResponse<void>> {
    this.invoiceCancelValidation(requestParameters);
    const context = this.invoiceCancelContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private invoiceCancelValidation(requestParameters: InvoiceCancelRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling invoiceCancel."
      );
    }
  }

  /**
   */
  private invoiceCancelContext(requestParameters: InvoiceCancelRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/invoice/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  invoiceCancel = async (id: string): Promise<void> => {
    await this.invoiceCancelRaw({ id: id });
  };

  useInvoiceCancel(id: string, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.invoiceCancelContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.invoiceCancel(id!) : undefined, config);
  }

  /**
   */
  private async invoicesRaw(): Promise<runtime.ApiResponse<Array<Invoice>>> {
    this.invoicesValidation();
    const context = this.invoicesContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(InvoiceFromJSON));
  }

  /**
   */
  private invoicesValidation() {}

  /**
   */
  private invoicesContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/invoice`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  invoices = async (): Promise<Array<Invoice>> => {
    const response = await this.invoicesRaw();
    return await response.value();
  };

  useInvoices(config?: ConfigInterface<Array<Invoice>, Error>) {
    let valid = true;

    const context = this.invoicesContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.invoices() : undefined, config);
  }

  /**
   */
  private async modulbankPaymentParamsRaw(
    requestParameters: ModulbankPaymentParamsRequest
  ): Promise<runtime.ApiResponse<ModulbankPayment>> {
    this.modulbankPaymentParamsValidation(requestParameters);
    const context = this.modulbankPaymentParamsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ModulbankPaymentFromJSON(jsonValue));
  }

  /**
   */
  private modulbankPaymentParamsValidation(requestParameters: ModulbankPaymentParamsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling modulbankPaymentParams."
      );
    }
  }

  /**
   */
  private modulbankPaymentParamsContext(requestParameters: ModulbankPaymentParamsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/payment/modulbank/{id}/payment-params`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  modulbankPaymentParams = async (id: string): Promise<ModulbankPayment> => {
    const response = await this.modulbankPaymentParamsRaw({ id: id });
    return await response.value();
  };

  useModulbankPaymentParams(id: string, config?: ConfigInterface<ModulbankPayment, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.modulbankPaymentParamsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.modulbankPaymentParams(id!) : undefined, config);
  }

  /**
   */
  private async myBalanceRaw(): Promise<runtime.ApiResponse<BalanceDTO>> {
    this.myBalanceValidation();
    const context = this.myBalanceContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => BalanceDTOFromJSON(jsonValue));
  }

  /**
   */
  private myBalanceValidation() {}

  /**
   */
  private myBalanceContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/balance/my`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  myBalance = async (): Promise<BalanceDTO> => {
    const response = await this.myBalanceRaw();
    return await response.value();
  };

  useMyBalance(config?: ConfigInterface<BalanceDTO, Error>) {
    let valid = true;

    const context = this.myBalanceContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.myBalance() : undefined, config);
  }

  /**
   */
  private async myTransactionsRaw(): Promise<runtime.ApiResponse<Array<BalanceTransactionDTO>>> {
    this.myTransactionsValidation();
    const context = this.myTransactionsContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(BalanceTransactionDTOFromJSON));
  }

  /**
   */
  private myTransactionsValidation() {}

  /**
   */
  private myTransactionsContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/balance/my/transactions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  myTransactions = async (): Promise<Array<BalanceTransactionDTO>> => {
    const response = await this.myTransactionsRaw();
    return await response.value();
  };

  useMyTransactions(config?: ConfigInterface<Array<BalanceTransactionDTO>, Error>) {
    let valid = true;

    const context = this.myTransactionsContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.myTransactions() : undefined, config);
  }

  /**
   */
  private async paymentParamsRaw(
    requestParameters: PaymentParamsRequest
  ): Promise<runtime.ApiResponse<BalancePayment>> {
    this.paymentParamsValidation(requestParameters);
    const context = this.paymentParamsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => BalancePaymentFromJSON(jsonValue));
  }

  /**
   */
  private paymentParamsValidation(requestParameters: PaymentParamsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling paymentParams."
      );
    }
  }

  /**
   */
  private paymentParamsContext(requestParameters: PaymentParamsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/payment/balance/{id}/payment-params`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  paymentParams = async (id: string): Promise<BalancePayment> => {
    const response = await this.paymentParamsRaw({ id: id });
    return await response.value();
  };

  usePaymentParams(id: string, config?: ConfigInterface<BalancePayment, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.paymentParamsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.paymentParams(id!) : undefined, config);
  }

  /**
   */
  private async paypalPaymentParamsRaw(
    requestParameters: PaypalPaymentParamsRequest
  ): Promise<runtime.ApiResponse<PaypalPayment>> {
    this.paypalPaymentParamsValidation(requestParameters);
    const context = this.paypalPaymentParamsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PaypalPaymentFromJSON(jsonValue));
  }

  /**
   */
  private paypalPaymentParamsValidation(requestParameters: PaypalPaymentParamsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling paypalPaymentParams."
      );
    }
  }

  /**
   */
  private paypalPaymentParamsContext(requestParameters: PaypalPaymentParamsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/payment/paypal/{id}/payment-params`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  paypalPaymentParams = async (id: string): Promise<PaypalPayment> => {
    const response = await this.paypalPaymentParamsRaw({ id: id });
    return await response.value();
  };

  usePaypalPaymentParams(id: string, config?: ConfigInterface<PaypalPayment, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.paypalPaymentParamsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.paypalPaymentParams(id!) : undefined, config);
  }

  /**
   */
  private async stripePaymentParamsRaw(
    requestParameters: StripePaymentParamsRequest
  ): Promise<runtime.ApiResponse<StripePayment>> {
    this.stripePaymentParamsValidation(requestParameters);
    const context = this.stripePaymentParamsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => StripePaymentFromJSON(jsonValue));
  }

  /**
   */
  private stripePaymentParamsValidation(requestParameters: StripePaymentParamsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling stripePaymentParams."
      );
    }
  }

  /**
   */
  private stripePaymentParamsContext(requestParameters: StripePaymentParamsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/payment/stripe/{id}/payment-params`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  stripePaymentParams = async (id: string): Promise<StripePayment> => {
    const response = await this.stripePaymentParamsRaw({ id: id });
    return await response.value();
  };

  useStripePaymentParams(id: string, config?: ConfigInterface<StripePayment, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.stripePaymentParamsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.stripePaymentParams(id!) : undefined, config);
  }

  /**
   */
  private async subscriptionRaw(requestParameters: SubscriptionRequest): Promise<runtime.ApiResponse<Subscription>> {
    this.subscriptionValidation(requestParameters);
    const context = this.subscriptionContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => SubscriptionFromJSON(jsonValue));
  }

  /**
   */
  private subscriptionValidation(requestParameters: SubscriptionRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling subscription."
      );
    }
  }

  /**
   */
  private subscriptionContext(requestParameters: SubscriptionRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/subscriptions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  subscription = async (id: string): Promise<Subscription> => {
    const response = await this.subscriptionRaw({ id: id });
    return await response.value();
  };

  useSubscription(id: string, config?: ConfigInterface<Subscription, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.subscriptionContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.subscription(id!) : undefined, config);
  }

  /**
   */
  private async subscriptionDiscountsRaw(): Promise<runtime.ApiResponse<Array<Discount>>> {
    this.subscriptionDiscountsValidation();
    const context = this.subscriptionDiscountsContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(DiscountFromJSON));
  }

  /**
   */
  private subscriptionDiscountsValidation() {}

  /**
   */
  private subscriptionDiscountsContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/subscriptions/discounts`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  subscriptionDiscounts = async (): Promise<Array<Discount>> => {
    const response = await this.subscriptionDiscountsRaw();
    return await response.value();
  };

  useSubscriptionDiscounts(config?: ConfigInterface<Array<Discount>, Error>) {
    let valid = true;

    const context = this.subscriptionDiscountsContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.subscriptionDiscounts() : undefined, config);
  }

  /**
   */
  private async subscriptionListRaw(): Promise<runtime.ApiResponse<Array<Subscription>>> {
    this.subscriptionListValidation();
    const context = this.subscriptionListContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(SubscriptionFromJSON));
  }

  /**
   */
  private subscriptionListValidation() {}

  /**
   */
  private subscriptionListContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/subscriptions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  subscriptionList = async (): Promise<Array<Subscription>> => {
    const response = await this.subscriptionListRaw();
    return await response.value();
  };

  useSubscriptionList(config?: ConfigInterface<Array<Subscription>, Error>) {
    let valid = true;

    const context = this.subscriptionListContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.subscriptionList() : undefined, config);
  }

  /**
   */
  private async subscriptionProlongRaw(
    requestParameters: SubscriptionProlongRequest
  ): Promise<runtime.ApiResponse<SubscriptionInvoiceId>> {
    this.subscriptionProlongValidation(requestParameters);
    const context = this.subscriptionProlongContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => SubscriptionInvoiceIdFromJSON(jsonValue));
  }

  /**
   */
  private subscriptionProlongValidation(requestParameters: SubscriptionProlongRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling subscriptionProlong."
      );
    }
    if (
      requestParameters.subscriptionSwitchToMonthly === null ||
      requestParameters.subscriptionSwitchToMonthly === undefined
    ) {
      throw new runtime.RequiredError(
        "subscriptionSwitchToMonthly",
        "Required parameter requestParameters.subscriptionSwitchToMonthly was null or undefined when calling subscriptionProlong."
      );
    }
  }

  /**
   */
  private subscriptionProlongContext(requestParameters: SubscriptionProlongRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/subscriptions/{id}/prolong`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SubscriptionSwitchToMonthlyToJSON(requestParameters.subscriptionSwitchToMonthly)
    };
  }

  /**
   */
  subscriptionProlong = async (
    id: string,
    subscriptionSwitchToMonthly: SubscriptionSwitchToMonthly
  ): Promise<SubscriptionInvoiceId> => {
    const response = await this.subscriptionProlongRaw({
      id: id,
      subscriptionSwitchToMonthly: subscriptionSwitchToMonthly
    });
    return await response.value();
  };

  /**
   */
  private async subscriptionSwitchToHourlyRaw(
    requestParameters: SubscriptionSwitchToHourlyRequest
  ): Promise<runtime.ApiResponse<SubscriptionInvoiceId>> {
    this.subscriptionSwitchToHourlyValidation(requestParameters);
    const context = this.subscriptionSwitchToHourlyContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => SubscriptionInvoiceIdFromJSON(jsonValue));
  }

  /**
   */
  private subscriptionSwitchToHourlyValidation(requestParameters: SubscriptionSwitchToHourlyRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling subscriptionSwitchToHourly."
      );
    }
  }

  /**
   */
  private subscriptionSwitchToHourlyContext(requestParameters: SubscriptionSwitchToHourlyRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/subscriptions/{id}/switch-to-hourly`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  subscriptionSwitchToHourly = async (id: string): Promise<SubscriptionInvoiceId> => {
    const response = await this.subscriptionSwitchToHourlyRaw({ id: id });
    return await response.value();
  };

  /**
   */
  private async subscriptionSwitchToMonthlyRaw(
    requestParameters: SubscriptionSwitchToMonthlyRequest
  ): Promise<runtime.ApiResponse<SubscriptionInvoiceId>> {
    this.subscriptionSwitchToMonthlyValidation(requestParameters);
    const context = this.subscriptionSwitchToMonthlyContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => SubscriptionInvoiceIdFromJSON(jsonValue));
  }

  /**
   */
  private subscriptionSwitchToMonthlyValidation(requestParameters: SubscriptionSwitchToMonthlyRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling subscriptionSwitchToMonthly."
      );
    }
    if (
      requestParameters.subscriptionSwitchToMonthly === null ||
      requestParameters.subscriptionSwitchToMonthly === undefined
    ) {
      throw new runtime.RequiredError(
        "subscriptionSwitchToMonthly",
        "Required parameter requestParameters.subscriptionSwitchToMonthly was null or undefined when calling subscriptionSwitchToMonthly."
      );
    }
  }

  /**
   */
  private subscriptionSwitchToMonthlyContext(
    requestParameters: SubscriptionSwitchToMonthlyRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/billing/subscriptions/{id}/switch-to-monthly`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SubscriptionSwitchToMonthlyToJSON(requestParameters.subscriptionSwitchToMonthly)
    };
  }

  /**
   */
  subscriptionSwitchToMonthly = async (
    id: string,
    subscriptionSwitchToMonthly: SubscriptionSwitchToMonthly
  ): Promise<SubscriptionInvoiceId> => {
    const response = await this.subscriptionSwitchToMonthlyRaw({
      id: id,
      subscriptionSwitchToMonthly: subscriptionSwitchToMonthly
    });
    return await response.value();
  };
}
