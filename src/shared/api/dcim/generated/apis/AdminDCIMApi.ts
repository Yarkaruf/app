/* tslint:disable */
/* eslint-disable */
/**
 * Medialand API
 * Medialand API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import useSWR, { ConfigInterface } from "swr";

import {
  Asset,
  AssetFromJSON,
  AssetToJSON,
  AssetDto,
  AssetDtoFromJSON,
  AssetDtoToJSON,
  AssetTree,
  AssetTreeFromJSON,
  AssetTreeToJSON,
  AssignToRackDto,
  AssignToRackDtoFromJSON,
  AssignToRackDtoToJSON,
  AssignToWarehouseDto,
  AssignToWarehouseDtoFromJSON,
  AssignToWarehouseDtoToJSON,
  AssignViaConnectorDto,
  AssignViaConnectorDtoFromJSON,
  AssignViaConnectorDtoToJSON,
  CreateManyAssetDto,
  CreateManyAssetDtoFromJSON,
  CreateManyAssetDtoToJSON,
  CreateManyDiskDto,
  CreateManyDiskDtoFromJSON,
  CreateManyDiskDtoToJSON,
  CreateManyManufacturerDto,
  CreateManyManufacturerDtoFromJSON,
  CreateManyManufacturerDtoToJSON,
  CreateManyNetworkInterfaceDto,
  CreateManyNetworkInterfaceDtoFromJSON,
  CreateManyNetworkInterfaceDtoToJSON,
  CreateManyPlatformDto,
  CreateManyPlatformDtoFromJSON,
  CreateManyPlatformDtoToJSON,
  CreateManyPowerUnitDto,
  CreateManyPowerUnitDtoFromJSON,
  CreateManyPowerUnitDtoToJSON,
  CreateManyProcessorDto,
  CreateManyProcessorDtoFromJSON,
  CreateManyProcessorDtoToJSON,
  CreateManyRAIDControllerDto,
  CreateManyRAIDControllerDtoFromJSON,
  CreateManyRAIDControllerDtoToJSON,
  CreateManyRAMDto,
  CreateManyRAMDtoFromJSON,
  CreateManyRAMDtoToJSON,
  CreateManySwitchDto,
  CreateManySwitchDtoFromJSON,
  CreateManySwitchDtoToJSON,
  CreateManyTicketDto,
  CreateManyTicketDtoFromJSON,
  CreateManyTicketDtoToJSON,
  CreateManyTransferDto,
  CreateManyTransferDtoFromJSON,
  CreateManyTransferDtoToJSON,
  CreateManyWarehouseDto,
  CreateManyWarehouseDtoFromJSON,
  CreateManyWarehouseDtoToJSON,
  CreateUpdateServerDto,
  CreateUpdateServerDtoFromJSON,
  CreateUpdateServerDtoToJSON,
  DataCenter,
  DataCenterFromJSON,
  DataCenterToJSON,
  DeployServerDto,
  DeployServerDtoFromJSON,
  DeployServerDtoToJSON,
  Disk,
  DiskFromJSON,
  DiskToJSON,
  DiskDto,
  DiskDtoFromJSON,
  DiskDtoToJSON,
  FreeAddressDto,
  FreeAddressDtoFromJSON,
  FreeAddressDtoToJSON,
  InterfaceRole,
  InterfaceRoleFromJSON,
  InterfaceRoleToJSON,
  Manufacturer,
  ManufacturerFromJSON,
  ManufacturerToJSON,
  ManufacturerDto,
  ManufacturerDtoFromJSON,
  ManufacturerDtoToJSON,
  NetworkInterface,
  NetworkInterfaceFromJSON,
  NetworkInterfaceToJSON,
  NetworkInterfaceDto,
  NetworkInterfaceDtoFromJSON,
  NetworkInterfaceDtoToJSON,
  OperatingSystem,
  OperatingSystemFromJSON,
  OperatingSystemToJSON,
  Platform,
  PlatformFromJSON,
  PlatformToJSON,
  PlatformDto,
  PlatformDtoFromJSON,
  PlatformDtoToJSON,
  PowerUnit,
  PowerUnitFromJSON,
  PowerUnitToJSON,
  PowerUnitDto,
  PowerUnitDtoFromJSON,
  PowerUnitDtoToJSON,
  Prefix,
  PrefixFromJSON,
  PrefixToJSON,
  Processor,
  ProcessorFromJSON,
  ProcessorToJSON,
  ProcessorDto,
  ProcessorDtoFromJSON,
  ProcessorDtoToJSON,
  RAIDController,
  RAIDControllerFromJSON,
  RAIDControllerToJSON,
  RAIDControllerDto,
  RAIDControllerDtoFromJSON,
  RAIDControllerDtoToJSON,
  RAM,
  RAMFromJSON,
  RAMToJSON,
  RAMDto,
  RAMDtoFromJSON,
  RAMDtoToJSON,
  Rack,
  RackFromJSON,
  RackToJSON,
  RackUnit,
  RackUnitFromJSON,
  RackUnitToJSON,
  Server,
  ServerFromJSON,
  ServerToJSON,
  ServerCredentialsCollection,
  ServerCredentialsCollectionFromJSON,
  ServerCredentialsCollectionToJSON,
  ServerRole,
  ServerRoleFromJSON,
  ServerRoleToJSON,
  ServerTestResultDto,
  ServerTestResultDtoFromJSON,
  ServerTestResultDtoToJSON,
  Switch,
  SwitchFromJSON,
  SwitchToJSON,
  SwitchDto,
  SwitchDtoFromJSON,
  SwitchDtoToJSON,
  Ticket,
  TicketFromJSON,
  TicketToJSON,
  TicketDto,
  TicketDtoFromJSON,
  TicketDtoToJSON,
  Transfer,
  TransferFromJSON,
  TransferToJSON,
  TransferDto,
  TransferDtoFromJSON,
  TransferDtoToJSON,
  UpdateInterfaceDto,
  UpdateInterfaceDtoFromJSON,
  UpdateInterfaceDtoToJSON,
  UpdateServerTariffDto,
  UpdateServerTariffDtoFromJSON,
  UpdateServerTariffDtoToJSON,
  Warehouse,
  WarehouseFromJSON,
  WarehouseToJSON,
  WarehouseDto,
  WarehouseDtoFromJSON,
  WarehouseDtoToJSON
} from "../models";

interface AllowedAssignmentsRequest {
  id: string;
}

interface ApplyRequest {
  id: number;
}

interface AssetTreeRequest {
  id: string;
}

interface AssignTariffRequest {
  serverId: number;
}

interface AssignToLocationRequest {
  assignToRackDto: AssignToRackDto;
}

interface AssignToWarehouseRequest {
  assignToWarehouseDto: AssignToWarehouseDto;
}

interface AssignViaConnectorRequest {
  assignViaConnectorDto: AssignViaConnectorDto;
}

interface CanHoldListRequest {
  id: string;
  transfer?: string;
}

interface CancelRequest {
  id: number;
}

interface CreateManyBaseAssetControllerAssetRequest {
  createManyAssetDto: CreateManyAssetDto;
}

interface CreateManyBaseDiskControllerDiskRequest {
  createManyDiskDto: CreateManyDiskDto;
}

interface CreateManyBaseManufacturerControllerManufacturerRequest {
  createManyManufacturerDto: CreateManyManufacturerDto;
}

interface CreateManyBaseNetworkInterfaceControllerNetworkInterfaceRequest {
  createManyNetworkInterfaceDto: CreateManyNetworkInterfaceDto;
}

interface CreateManyBasePlatformControllerPlatformRequest {
  createManyPlatformDto: CreateManyPlatformDto;
}

interface CreateManyBasePowerUnitControllerPowerUnitRequest {
  createManyPowerUnitDto: CreateManyPowerUnitDto;
}

interface CreateManyBaseProcessorControllerProcessorRequest {
  createManyProcessorDto: CreateManyProcessorDto;
}

interface CreateManyBaseRAIDControllerControllerRAIDControllerRequest {
  createManyRAIDControllerDto: CreateManyRAIDControllerDto;
}

interface CreateManyBaseRAMControllerRAMRequest {
  createManyRAMDto: CreateManyRAMDto;
}

interface CreateManyBaseSwitchControllerSwitchRequest {
  createManySwitchDto: CreateManySwitchDto;
}

interface CreateManyBaseTicketControllerTicketRequest {
  createManyTicketDto: CreateManyTicketDto;
}

interface CreateManyBaseTransferControllerTransferRequest {
  createManyTransferDto: CreateManyTransferDto;
}

interface CreateManyBaseWarehouseControllerWarehouseRequest {
  createManyWarehouseDto: CreateManyWarehouseDto;
}

interface CreateOneBaseAssetControllerAssetRequest {
  assetDto: AssetDto;
}

interface CreateOneBaseDiskControllerDiskRequest {
  diskDto: DiskDto;
}

interface CreateOneBaseManufacturerControllerManufacturerRequest {
  manufacturerDto: ManufacturerDto;
}

interface CreateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest {
  networkInterfaceDto: NetworkInterfaceDto;
}

interface CreateOneBasePlatformControllerPlatformRequest {
  platformDto: PlatformDto;
}

interface CreateOneBasePowerUnitControllerPowerUnitRequest {
  powerUnitDto: PowerUnitDto;
}

interface CreateOneBaseProcessorControllerProcessorRequest {
  processorDto: ProcessorDto;
}

interface CreateOneBaseRAIDControllerControllerRAIDControllerRequest {
  rAIDControllerDto: RAIDControllerDto;
}

interface CreateOneBaseRAMControllerRAMRequest {
  rAMDto: RAMDto;
}

interface CreateOneBaseSwitchControllerSwitchRequest {
  switchDto: SwitchDto;
}

interface CreateOneBaseTicketControllerTicketRequest {
  ticketDto: TicketDto;
}

interface CreateOneBaseTransferControllerTransferRequest {
  transferDto: TransferDto;
}

interface CreateOneBaseWarehouseControllerWarehouseRequest {
  warehouseDto: WarehouseDto;
}

interface CreateServerRequest {
  createUpdateServerDto: CreateUpdateServerDto;
}

interface DeleteAssignmentRequest {
  transferId: string;
  assignmentId: string;
}

interface DeleteOneBaseAssetControllerAssetRequest {
  id: string;
}

interface DeleteOneBaseManufacturerControllerManufacturerRequest {
  id: string;
}

interface DeleteOneBaseModelControllerModelRequest {
  id: string;
}

interface DeleteOneBaseTicketControllerTicketRequest {
  id: number;
}

interface DeleteOneBaseTransferControllerTransferRequest {
  id: string;
}

interface DeleteOneBaseWarehouseControllerWarehouseRequest {
  id: string;
}

interface DeleteServerRequest {
  serverId: number;
}

interface DeployServerRequest {
  id: number;
  deployServerDto: DeployServerDto;
}

interface FreeIPAddressRequest {
  prefixId: number;
}

interface GetManyBaseAssetControllerAssetRequest {
  fields?: Array<string>;
  s?: string;
  filter?: Array<string>;
  or?: Array<string>;
  sort?: Array<string>;
  join?: Array<string>;
  limit?: number;
  offset?: number;
  page?: number;
  cache?: number;
}

interface GetManyBaseManufacturerControllerManufacturerRequest {
  fields?: Array<string>;
  s?: string;
  filter?: Array<string>;
  or?: Array<string>;
  sort?: Array<string>;
  join?: Array<string>;
  limit?: number;
  offset?: number;
  page?: number;
  cache?: number;
}

interface GetManyBaseModelControllerModelRequest {
  fields?: Array<string>;
  s?: string;
  filter?: Array<string>;
  or?: Array<string>;
  sort?: Array<string>;
  join?: Array<string>;
  limit?: number;
  offset?: number;
  page?: number;
  cache?: number;
}

interface GetManyBaseTicketControllerTicketRequest {
  fields?: Array<string>;
  s?: string;
  filter?: Array<string>;
  or?: Array<string>;
  sort?: Array<string>;
  join?: Array<string>;
  limit?: number;
  offset?: number;
  page?: number;
  cache?: number;
}

interface GetManyBaseTransferControllerTransferRequest {
  fields?: Array<string>;
  s?: string;
  filter?: Array<string>;
  or?: Array<string>;
  sort?: Array<string>;
  join?: Array<string>;
  limit?: number;
  offset?: number;
  page?: number;
  cache?: number;
}

interface GetManyBaseWarehouseControllerWarehouseRequest {
  fields?: Array<string>;
  s?: string;
  filter?: Array<string>;
  or?: Array<string>;
  sort?: Array<string>;
  join?: Array<string>;
  limit?: number;
  offset?: number;
  page?: number;
  cache?: number;
}

interface GetOneBaseAssetControllerAssetRequest {
  id: string;
  fields?: Array<string>;
  join?: Array<string>;
  cache?: number;
}

interface GetOneBaseManufacturerControllerManufacturerRequest {
  id: string;
  fields?: Array<string>;
  join?: Array<string>;
  cache?: number;
}

interface GetOneBaseModelControllerModelRequest {
  id: string;
  fields?: Array<string>;
  join?: Array<string>;
  cache?: number;
}

interface GetOneBaseTicketControllerTicketRequest {
  id: number;
  fields?: Array<string>;
  join?: Array<string>;
  cache?: number;
}

interface GetOneBaseTransferControllerTransferRequest {
  id: string;
  fields?: Array<string>;
  join?: Array<string>;
  cache?: number;
}

interface GetOneBaseWarehouseControllerWarehouseRequest {
  id: string;
  fields?: Array<string>;
  join?: Array<string>;
  cache?: number;
}

interface LocationRequest {
  id: number;
}

interface PrefixesRequest {
  locationId: number;
}

interface RackRequest {
  id: number;
}

interface RackElevationRequest {
  id: number;
}

interface RacksRequest {
  siteId?: number;
}

interface ReloadServerStatusRequest {
  id: number;
}

interface ResetServerRequest {
  id: number;
}

interface ServerRequest {
  id: number;
}

interface ServerTestsRequest {
  id: number;
}

interface ServerUpdateInterfacesRequest {
  serverId: number;
  updateInterfaceDto: Array<UpdateInterfaceDto>;
}

interface ServersRequest {
  type?: ServersTypeEnum;
  withInterfaces?: boolean;
}

interface TurnOffServerRequest {
  id: number;
}

interface TurnOnServerRequest {
  id: number;
}

interface UpdateOneBaseAssetControllerAssetRequest {
  id: string;
  assetDto: AssetDto;
}

interface UpdateOneBaseDiskControllerDiskRequest {
  id: string;
  diskDto: DiskDto;
}

interface UpdateOneBaseManufacturerControllerManufacturerRequest {
  id: string;
  manufacturerDto: ManufacturerDto;
}

interface UpdateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest {
  id: string;
  networkInterfaceDto: NetworkInterfaceDto;
}

interface UpdateOneBasePlatformControllerPlatformRequest {
  id: string;
  platformDto: PlatformDto;
}

interface UpdateOneBasePowerUnitControllerPowerUnitRequest {
  id: string;
  powerUnitDto: PowerUnitDto;
}

interface UpdateOneBaseProcessorControllerProcessorRequest {
  id: string;
  processorDto: ProcessorDto;
}

interface UpdateOneBaseRAIDControllerControllerRAIDControllerRequest {
  id: string;
  rAIDControllerDto: RAIDControllerDto;
}

interface UpdateOneBaseRAMControllerRAMRequest {
  id: string;
  rAMDto: RAMDto;
}

interface UpdateOneBaseSwitchControllerSwitchRequest {
  id: string;
  switchDto: SwitchDto;
}

interface UpdateOneBaseTicketControllerTicketRequest {
  id: number;
  ticketDto: TicketDto;
}

interface UpdateOneBaseTransferControllerTransferRequest {
  id: string;
  transferDto: TransferDto;
}

interface UpdateOneBaseWarehouseControllerWarehouseRequest {
  id: string;
  warehouseDto: WarehouseDto;
}

interface UpdateServerRequest {
  id: number;
  createUpdateServerDto: CreateUpdateServerDto;
}

interface UpdateServerCredentialsRequest {
  id: number;
  serverCredentialsCollection: ServerCredentialsCollection;
}

interface UpdateServerTariffRequest {
  id: number;
  updateServerTariffDto: UpdateServerTariffDto;
}

/**
 *
 */
export class AdminDCIMApi extends runtime.BaseAPI {
  /**
   */
  private async allowedAssignmentsRaw(
    requestParameters: AllowedAssignmentsRequest
  ): Promise<runtime.ApiResponse<Array<object>>> {
    this.allowedAssignmentsValidation(requestParameters);
    const context = this.allowedAssignmentsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private allowedAssignmentsValidation(requestParameters: AllowedAssignmentsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling allowedAssignments."
      );
    }
  }

  /**
   */
  private allowedAssignmentsContext(requestParameters: AllowedAssignmentsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/{id}/can-assign-list`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  allowedAssignments = async (id: string): Promise<Array<object>> => {
    const response = await this.allowedAssignmentsRaw({ id: id });
    return await response.value();
  };

  useAllowedAssignments(id: string, config?: ConfigInterface<Array<object>, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.allowedAssignmentsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.allowedAssignments(id!) : undefined, config);
  }

  /**
   */
  private async applyRaw(requestParameters: ApplyRequest): Promise<runtime.ApiResponse<object>> {
    this.applyValidation(requestParameters);
    const context = this.applyContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private applyValidation(requestParameters: ApplyRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling apply."
      );
    }
  }

  /**
   */
  private applyContext(requestParameters: ApplyRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket/{id}/apply`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  apply = async (id: number): Promise<object> => {
    const response = await this.applyRaw({ id: id });
    return await response.value();
  };

  /**
   */
  private async assetTreeRaw(requestParameters: AssetTreeRequest): Promise<runtime.ApiResponse<AssetTree>> {
    this.assetTreeValidation(requestParameters);
    const context = this.assetTreeContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => AssetTreeFromJSON(jsonValue));
  }

  /**
   */
  private assetTreeValidation(requestParameters: AssetTreeRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling assetTree."
      );
    }
  }

  /**
   */
  private assetTreeContext(requestParameters: AssetTreeRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/{id}/tree`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  assetTree = async (id: string): Promise<AssetTree> => {
    const response = await this.assetTreeRaw({ id: id });
    return await response.value();
  };

  useAssetTree(id: string, config?: ConfigInterface<AssetTree, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.assetTreeContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.assetTree(id!) : undefined, config);
  }

  /**
   */
  private async assignTariffRaw(requestParameters: AssignTariffRequest): Promise<runtime.ApiResponse<Server>> {
    this.assignTariffValidation(requestParameters);
    const context = this.assignTariffContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ServerFromJSON(jsonValue));
  }

  /**
   */
  private assignTariffValidation(requestParameters: AssignTariffRequest) {
    if (requestParameters.serverId === null || requestParameters.serverId === undefined) {
      throw new runtime.RequiredError(
        "serverId",
        "Required parameter requestParameters.serverId was null or undefined when calling assignTariff."
      );
    }
  }

  /**
   */
  private assignTariffContext(requestParameters: AssignTariffRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{serverId}/tariff`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(requestParameters.serverId))
      ),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  assignTariff = async (serverId: number): Promise<Server> => {
    const response = await this.assignTariffRaw({ serverId: serverId });
    return await response.value();
  };

  /**
   */
  private async assignToLocationRaw(
    requestParameters: AssignToLocationRequest
  ): Promise<runtime.ApiResponse<Transfer>> {
    this.assignToLocationValidation(requestParameters);
    const context = this.assignToLocationContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TransferFromJSON(jsonValue));
  }

  /**
   */
  private assignToLocationValidation(requestParameters: AssignToLocationRequest) {
    if (requestParameters.assignToRackDto === null || requestParameters.assignToRackDto === undefined) {
      throw new runtime.RequiredError(
        "assignToRackDto",
        "Required parameter requestParameters.assignToRackDto was null or undefined when calling assignToLocation."
      );
    }
  }

  /**
   */
  private assignToLocationContext(requestParameters: AssignToLocationRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/assign/to-data-center`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AssignToRackDtoToJSON(requestParameters.assignToRackDto)
    };
  }

  /**
   */
  assignToLocation = async (assignToRackDto: AssignToRackDto): Promise<Transfer> => {
    const response = await this.assignToLocationRaw({ assignToRackDto: assignToRackDto });
    return await response.value();
  };

  /**
   */
  private async assignToWarehouseRaw(
    requestParameters: AssignToWarehouseRequest
  ): Promise<runtime.ApiResponse<Transfer>> {
    this.assignToWarehouseValidation(requestParameters);
    const context = this.assignToWarehouseContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TransferFromJSON(jsonValue));
  }

  /**
   */
  private assignToWarehouseValidation(requestParameters: AssignToWarehouseRequest) {
    if (requestParameters.assignToWarehouseDto === null || requestParameters.assignToWarehouseDto === undefined) {
      throw new runtime.RequiredError(
        "assignToWarehouseDto",
        "Required parameter requestParameters.assignToWarehouseDto was null or undefined when calling assignToWarehouse."
      );
    }
  }

  /**
   */
  private assignToWarehouseContext(requestParameters: AssignToWarehouseRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/assign/to-warehouse`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AssignToWarehouseDtoToJSON(requestParameters.assignToWarehouseDto)
    };
  }

  /**
   */
  assignToWarehouse = async (assignToWarehouseDto: AssignToWarehouseDto): Promise<Transfer> => {
    const response = await this.assignToWarehouseRaw({ assignToWarehouseDto: assignToWarehouseDto });
    return await response.value();
  };

  /**
   */
  private async assignViaConnectorRaw(
    requestParameters: AssignViaConnectorRequest
  ): Promise<runtime.ApiResponse<Transfer>> {
    this.assignViaConnectorValidation(requestParameters);
    const context = this.assignViaConnectorContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TransferFromJSON(jsonValue));
  }

  /**
   */
  private assignViaConnectorValidation(requestParameters: AssignViaConnectorRequest) {
    if (requestParameters.assignViaConnectorDto === null || requestParameters.assignViaConnectorDto === undefined) {
      throw new runtime.RequiredError(
        "assignViaConnectorDto",
        "Required parameter requestParameters.assignViaConnectorDto was null or undefined when calling assignViaConnector."
      );
    }
  }

  /**
   */
  private assignViaConnectorContext(requestParameters: AssignViaConnectorRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/assign/via-connector`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AssignViaConnectorDtoToJSON(requestParameters.assignViaConnectorDto)
    };
  }

  /**
   */
  assignViaConnector = async (assignViaConnectorDto: AssignViaConnectorDto): Promise<Transfer> => {
    const response = await this.assignViaConnectorRaw({ assignViaConnectorDto: assignViaConnectorDto });
    return await response.value();
  };

  /**
   */
  private async canHoldListRaw(requestParameters: CanHoldListRequest): Promise<runtime.ApiResponse<Array<object>>> {
    this.canHoldListValidation(requestParameters);
    const context = this.canHoldListContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private canHoldListValidation(requestParameters: CanHoldListRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling canHoldList."
      );
    }
  }

  /**
   */
  private canHoldListContext(requestParameters: CanHoldListRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.transfer !== undefined) {
      queryParameters["transfer"] = requestParameters.transfer;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/{id}/can-hold-list`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  canHoldList = async (id: string, transfer?: string): Promise<Array<object>> => {
    const response = await this.canHoldListRaw({ id: id, transfer: transfer });
    return await response.value();
  };

  useCanHoldList(id: string, transfer?: string, config?: ConfigInterface<Array<object>, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.canHoldListContext({ id: id!, transfer: transfer! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.canHoldList(id!, transfer!) : undefined, config);
  }

  /**
   */
  private async cancelRaw(requestParameters: CancelRequest): Promise<runtime.ApiResponse<object>> {
    this.cancelValidation(requestParameters);
    const context = this.cancelContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private cancelValidation(requestParameters: CancelRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling cancel."
      );
    }
  }

  /**
   */
  private cancelContext(requestParameters: CancelRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  cancel = async (id: number): Promise<object> => {
    const response = await this.cancelRaw({ id: id });
    return await response.value();
  };

  /**
   * Create multiple Assets
   */
  private async createManyBaseAssetControllerAssetRaw(
    requestParameters: CreateManyBaseAssetControllerAssetRequest
  ): Promise<runtime.ApiResponse<Array<Asset>>> {
    this.createManyBaseAssetControllerAssetValidation(requestParameters);
    const context = this.createManyBaseAssetControllerAssetContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(AssetFromJSON));
  }

  /**
   * Create multiple Assets
   */
  private createManyBaseAssetControllerAssetValidation(requestParameters: CreateManyBaseAssetControllerAssetRequest) {
    if (requestParameters.createManyAssetDto === null || requestParameters.createManyAssetDto === undefined) {
      throw new runtime.RequiredError(
        "createManyAssetDto",
        "Required parameter requestParameters.createManyAssetDto was null or undefined when calling createManyBaseAssetControllerAsset."
      );
    }
  }

  /**
   * Create multiple Assets
   */
  private createManyBaseAssetControllerAssetContext(
    requestParameters: CreateManyBaseAssetControllerAssetRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyAssetDtoToJSON(requestParameters.createManyAssetDto)
    };
  }

  /**
   * Create multiple Assets
   */
  createManyBaseAssetControllerAsset = async (createManyAssetDto: CreateManyAssetDto): Promise<Array<Asset>> => {
    const response = await this.createManyBaseAssetControllerAssetRaw({ createManyAssetDto: createManyAssetDto });
    return await response.value();
  };

  /**
   * Create multiple Disks
   */
  private async createManyBaseDiskControllerDiskRaw(
    requestParameters: CreateManyBaseDiskControllerDiskRequest
  ): Promise<runtime.ApiResponse<Array<Disk>>> {
    this.createManyBaseDiskControllerDiskValidation(requestParameters);
    const context = this.createManyBaseDiskControllerDiskContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(DiskFromJSON));
  }

  /**
   * Create multiple Disks
   */
  private createManyBaseDiskControllerDiskValidation(requestParameters: CreateManyBaseDiskControllerDiskRequest) {
    if (requestParameters.createManyDiskDto === null || requestParameters.createManyDiskDto === undefined) {
      throw new runtime.RequiredError(
        "createManyDiskDto",
        "Required parameter requestParameters.createManyDiskDto was null or undefined when calling createManyBaseDiskControllerDisk."
      );
    }
  }

  /**
   * Create multiple Disks
   */
  private createManyBaseDiskControllerDiskContext(
    requestParameters: CreateManyBaseDiskControllerDiskRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/disk/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyDiskDtoToJSON(requestParameters.createManyDiskDto)
    };
  }

  /**
   * Create multiple Disks
   */
  createManyBaseDiskControllerDisk = async (createManyDiskDto: CreateManyDiskDto): Promise<Array<Disk>> => {
    const response = await this.createManyBaseDiskControllerDiskRaw({ createManyDiskDto: createManyDiskDto });
    return await response.value();
  };

  /**
   * Create multiple Manufacturers
   */
  private async createManyBaseManufacturerControllerManufacturerRaw(
    requestParameters: CreateManyBaseManufacturerControllerManufacturerRequest
  ): Promise<runtime.ApiResponse<Array<Manufacturer>>> {
    this.createManyBaseManufacturerControllerManufacturerValidation(requestParameters);
    const context = this.createManyBaseManufacturerControllerManufacturerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(ManufacturerFromJSON));
  }

  /**
   * Create multiple Manufacturers
   */
  private createManyBaseManufacturerControllerManufacturerValidation(
    requestParameters: CreateManyBaseManufacturerControllerManufacturerRequest
  ) {
    if (
      requestParameters.createManyManufacturerDto === null ||
      requestParameters.createManyManufacturerDto === undefined
    ) {
      throw new runtime.RequiredError(
        "createManyManufacturerDto",
        "Required parameter requestParameters.createManyManufacturerDto was null or undefined when calling createManyBaseManufacturerControllerManufacturer."
      );
    }
  }

  /**
   * Create multiple Manufacturers
   */
  private createManyBaseManufacturerControllerManufacturerContext(
    requestParameters: CreateManyBaseManufacturerControllerManufacturerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/manufacturer/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyManufacturerDtoToJSON(requestParameters.createManyManufacturerDto)
    };
  }

  /**
   * Create multiple Manufacturers
   */
  createManyBaseManufacturerControllerManufacturer = async (
    createManyManufacturerDto: CreateManyManufacturerDto
  ): Promise<Array<Manufacturer>> => {
    const response = await this.createManyBaseManufacturerControllerManufacturerRaw({
      createManyManufacturerDto: createManyManufacturerDto
    });
    return await response.value();
  };

  /**
   * Create multiple NetworkInterfaces
   */
  private async createManyBaseNetworkInterfaceControllerNetworkInterfaceRaw(
    requestParameters: CreateManyBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ): Promise<runtime.ApiResponse<Array<NetworkInterface>>> {
    this.createManyBaseNetworkInterfaceControllerNetworkInterfaceValidation(requestParameters);
    const context = this.createManyBaseNetworkInterfaceControllerNetworkInterfaceContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(NetworkInterfaceFromJSON));
  }

  /**
   * Create multiple NetworkInterfaces
   */
  private createManyBaseNetworkInterfaceControllerNetworkInterfaceValidation(
    requestParameters: CreateManyBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ) {
    if (
      requestParameters.createManyNetworkInterfaceDto === null ||
      requestParameters.createManyNetworkInterfaceDto === undefined
    ) {
      throw new runtime.RequiredError(
        "createManyNetworkInterfaceDto",
        "Required parameter requestParameters.createManyNetworkInterfaceDto was null or undefined when calling createManyBaseNetworkInterfaceControllerNetworkInterface."
      );
    }
  }

  /**
   * Create multiple NetworkInterfaces
   */
  private createManyBaseNetworkInterfaceControllerNetworkInterfaceContext(
    requestParameters: CreateManyBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/network-interface/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyNetworkInterfaceDtoToJSON(requestParameters.createManyNetworkInterfaceDto)
    };
  }

  /**
   * Create multiple NetworkInterfaces
   */
  createManyBaseNetworkInterfaceControllerNetworkInterface = async (
    createManyNetworkInterfaceDto: CreateManyNetworkInterfaceDto
  ): Promise<Array<NetworkInterface>> => {
    const response = await this.createManyBaseNetworkInterfaceControllerNetworkInterfaceRaw({
      createManyNetworkInterfaceDto: createManyNetworkInterfaceDto
    });
    return await response.value();
  };

  /**
   * Create multiple Platforms
   */
  private async createManyBasePlatformControllerPlatformRaw(
    requestParameters: CreateManyBasePlatformControllerPlatformRequest
  ): Promise<runtime.ApiResponse<Array<Platform>>> {
    this.createManyBasePlatformControllerPlatformValidation(requestParameters);
    const context = this.createManyBasePlatformControllerPlatformContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(PlatformFromJSON));
  }

  /**
   * Create multiple Platforms
   */
  private createManyBasePlatformControllerPlatformValidation(
    requestParameters: CreateManyBasePlatformControllerPlatformRequest
  ) {
    if (requestParameters.createManyPlatformDto === null || requestParameters.createManyPlatformDto === undefined) {
      throw new runtime.RequiredError(
        "createManyPlatformDto",
        "Required parameter requestParameters.createManyPlatformDto was null or undefined when calling createManyBasePlatformControllerPlatform."
      );
    }
  }

  /**
   * Create multiple Platforms
   */
  private createManyBasePlatformControllerPlatformContext(
    requestParameters: CreateManyBasePlatformControllerPlatformRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/platform/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyPlatformDtoToJSON(requestParameters.createManyPlatformDto)
    };
  }

  /**
   * Create multiple Platforms
   */
  createManyBasePlatformControllerPlatform = async (
    createManyPlatformDto: CreateManyPlatformDto
  ): Promise<Array<Platform>> => {
    const response = await this.createManyBasePlatformControllerPlatformRaw({
      createManyPlatformDto: createManyPlatformDto
    });
    return await response.value();
  };

  /**
   * Create multiple PowerUnits
   */
  private async createManyBasePowerUnitControllerPowerUnitRaw(
    requestParameters: CreateManyBasePowerUnitControllerPowerUnitRequest
  ): Promise<runtime.ApiResponse<Array<PowerUnit>>> {
    this.createManyBasePowerUnitControllerPowerUnitValidation(requestParameters);
    const context = this.createManyBasePowerUnitControllerPowerUnitContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(PowerUnitFromJSON));
  }

  /**
   * Create multiple PowerUnits
   */
  private createManyBasePowerUnitControllerPowerUnitValidation(
    requestParameters: CreateManyBasePowerUnitControllerPowerUnitRequest
  ) {
    if (requestParameters.createManyPowerUnitDto === null || requestParameters.createManyPowerUnitDto === undefined) {
      throw new runtime.RequiredError(
        "createManyPowerUnitDto",
        "Required parameter requestParameters.createManyPowerUnitDto was null or undefined when calling createManyBasePowerUnitControllerPowerUnit."
      );
    }
  }

  /**
   * Create multiple PowerUnits
   */
  private createManyBasePowerUnitControllerPowerUnitContext(
    requestParameters: CreateManyBasePowerUnitControllerPowerUnitRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/power-unit/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyPowerUnitDtoToJSON(requestParameters.createManyPowerUnitDto)
    };
  }

  /**
   * Create multiple PowerUnits
   */
  createManyBasePowerUnitControllerPowerUnit = async (
    createManyPowerUnitDto: CreateManyPowerUnitDto
  ): Promise<Array<PowerUnit>> => {
    const response = await this.createManyBasePowerUnitControllerPowerUnitRaw({
      createManyPowerUnitDto: createManyPowerUnitDto
    });
    return await response.value();
  };

  /**
   * Create multiple Processors
   */
  private async createManyBaseProcessorControllerProcessorRaw(
    requestParameters: CreateManyBaseProcessorControllerProcessorRequest
  ): Promise<runtime.ApiResponse<Array<Processor>>> {
    this.createManyBaseProcessorControllerProcessorValidation(requestParameters);
    const context = this.createManyBaseProcessorControllerProcessorContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(ProcessorFromJSON));
  }

  /**
   * Create multiple Processors
   */
  private createManyBaseProcessorControllerProcessorValidation(
    requestParameters: CreateManyBaseProcessorControllerProcessorRequest
  ) {
    if (requestParameters.createManyProcessorDto === null || requestParameters.createManyProcessorDto === undefined) {
      throw new runtime.RequiredError(
        "createManyProcessorDto",
        "Required parameter requestParameters.createManyProcessorDto was null or undefined when calling createManyBaseProcessorControllerProcessor."
      );
    }
  }

  /**
   * Create multiple Processors
   */
  private createManyBaseProcessorControllerProcessorContext(
    requestParameters: CreateManyBaseProcessorControllerProcessorRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/processor/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyProcessorDtoToJSON(requestParameters.createManyProcessorDto)
    };
  }

  /**
   * Create multiple Processors
   */
  createManyBaseProcessorControllerProcessor = async (
    createManyProcessorDto: CreateManyProcessorDto
  ): Promise<Array<Processor>> => {
    const response = await this.createManyBaseProcessorControllerProcessorRaw({
      createManyProcessorDto: createManyProcessorDto
    });
    return await response.value();
  };

  /**
   * Create multiple RAIDControllers
   */
  private async createManyBaseRAIDControllerControllerRAIDControllerRaw(
    requestParameters: CreateManyBaseRAIDControllerControllerRAIDControllerRequest
  ): Promise<runtime.ApiResponse<Array<RAIDController>>> {
    this.createManyBaseRAIDControllerControllerRAIDControllerValidation(requestParameters);
    const context = this.createManyBaseRAIDControllerControllerRAIDControllerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(RAIDControllerFromJSON));
  }

  /**
   * Create multiple RAIDControllers
   */
  private createManyBaseRAIDControllerControllerRAIDControllerValidation(
    requestParameters: CreateManyBaseRAIDControllerControllerRAIDControllerRequest
  ) {
    if (
      requestParameters.createManyRAIDControllerDto === null ||
      requestParameters.createManyRAIDControllerDto === undefined
    ) {
      throw new runtime.RequiredError(
        "createManyRAIDControllerDto",
        "Required parameter requestParameters.createManyRAIDControllerDto was null or undefined when calling createManyBaseRAIDControllerControllerRAIDController."
      );
    }
  }

  /**
   * Create multiple RAIDControllers
   */
  private createManyBaseRAIDControllerControllerRAIDControllerContext(
    requestParameters: CreateManyBaseRAIDControllerControllerRAIDControllerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/raid-controller/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyRAIDControllerDtoToJSON(requestParameters.createManyRAIDControllerDto)
    };
  }

  /**
   * Create multiple RAIDControllers
   */
  createManyBaseRAIDControllerControllerRAIDController = async (
    createManyRAIDControllerDto: CreateManyRAIDControllerDto
  ): Promise<Array<RAIDController>> => {
    const response = await this.createManyBaseRAIDControllerControllerRAIDControllerRaw({
      createManyRAIDControllerDto: createManyRAIDControllerDto
    });
    return await response.value();
  };

  /**
   * Create multiple RAMS
   */
  private async createManyBaseRAMControllerRAMRaw(
    requestParameters: CreateManyBaseRAMControllerRAMRequest
  ): Promise<runtime.ApiResponse<Array<RAM>>> {
    this.createManyBaseRAMControllerRAMValidation(requestParameters);
    const context = this.createManyBaseRAMControllerRAMContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(RAMFromJSON));
  }

  /**
   * Create multiple RAMS
   */
  private createManyBaseRAMControllerRAMValidation(requestParameters: CreateManyBaseRAMControllerRAMRequest) {
    if (requestParameters.createManyRAMDto === null || requestParameters.createManyRAMDto === undefined) {
      throw new runtime.RequiredError(
        "createManyRAMDto",
        "Required parameter requestParameters.createManyRAMDto was null or undefined when calling createManyBaseRAMControllerRAM."
      );
    }
  }

  /**
   * Create multiple RAMS
   */
  private createManyBaseRAMControllerRAMContext(
    requestParameters: CreateManyBaseRAMControllerRAMRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/ram/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyRAMDtoToJSON(requestParameters.createManyRAMDto)
    };
  }

  /**
   * Create multiple RAMS
   */
  createManyBaseRAMControllerRAM = async (createManyRAMDto: CreateManyRAMDto): Promise<Array<RAM>> => {
    const response = await this.createManyBaseRAMControllerRAMRaw({ createManyRAMDto: createManyRAMDto });
    return await response.value();
  };

  /**
   * Create multiple Switches
   */
  private async createManyBaseSwitchControllerSwitchRaw(
    requestParameters: CreateManyBaseSwitchControllerSwitchRequest
  ): Promise<runtime.ApiResponse<Array<Switch>>> {
    this.createManyBaseSwitchControllerSwitchValidation(requestParameters);
    const context = this.createManyBaseSwitchControllerSwitchContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(SwitchFromJSON));
  }

  /**
   * Create multiple Switches
   */
  private createManyBaseSwitchControllerSwitchValidation(
    requestParameters: CreateManyBaseSwitchControllerSwitchRequest
  ) {
    if (requestParameters.createManySwitchDto === null || requestParameters.createManySwitchDto === undefined) {
      throw new runtime.RequiredError(
        "createManySwitchDto",
        "Required parameter requestParameters.createManySwitchDto was null or undefined when calling createManyBaseSwitchControllerSwitch."
      );
    }
  }

  /**
   * Create multiple Switches
   */
  private createManyBaseSwitchControllerSwitchContext(
    requestParameters: CreateManyBaseSwitchControllerSwitchRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/switch/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManySwitchDtoToJSON(requestParameters.createManySwitchDto)
    };
  }

  /**
   * Create multiple Switches
   */
  createManyBaseSwitchControllerSwitch = async (createManySwitchDto: CreateManySwitchDto): Promise<Array<Switch>> => {
    const response = await this.createManyBaseSwitchControllerSwitchRaw({ createManySwitchDto: createManySwitchDto });
    return await response.value();
  };

  /**
   * Create multiple Tickets
   */
  private async createManyBaseTicketControllerTicketRaw(
    requestParameters: CreateManyBaseTicketControllerTicketRequest
  ): Promise<runtime.ApiResponse<Array<Ticket>>> {
    this.createManyBaseTicketControllerTicketValidation(requestParameters);
    const context = this.createManyBaseTicketControllerTicketContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(TicketFromJSON));
  }

  /**
   * Create multiple Tickets
   */
  private createManyBaseTicketControllerTicketValidation(
    requestParameters: CreateManyBaseTicketControllerTicketRequest
  ) {
    if (requestParameters.createManyTicketDto === null || requestParameters.createManyTicketDto === undefined) {
      throw new runtime.RequiredError(
        "createManyTicketDto",
        "Required parameter requestParameters.createManyTicketDto was null or undefined when calling createManyBaseTicketControllerTicket."
      );
    }
  }

  /**
   * Create multiple Tickets
   */
  private createManyBaseTicketControllerTicketContext(
    requestParameters: CreateManyBaseTicketControllerTicketRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyTicketDtoToJSON(requestParameters.createManyTicketDto)
    };
  }

  /**
   * Create multiple Tickets
   */
  createManyBaseTicketControllerTicket = async (createManyTicketDto: CreateManyTicketDto): Promise<Array<Ticket>> => {
    const response = await this.createManyBaseTicketControllerTicketRaw({ createManyTicketDto: createManyTicketDto });
    return await response.value();
  };

  /**
   * Create multiple Transfers
   */
  private async createManyBaseTransferControllerTransferRaw(
    requestParameters: CreateManyBaseTransferControllerTransferRequest
  ): Promise<runtime.ApiResponse<Array<Transfer>>> {
    this.createManyBaseTransferControllerTransferValidation(requestParameters);
    const context = this.createManyBaseTransferControllerTransferContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(TransferFromJSON));
  }

  /**
   * Create multiple Transfers
   */
  private createManyBaseTransferControllerTransferValidation(
    requestParameters: CreateManyBaseTransferControllerTransferRequest
  ) {
    if (requestParameters.createManyTransferDto === null || requestParameters.createManyTransferDto === undefined) {
      throw new runtime.RequiredError(
        "createManyTransferDto",
        "Required parameter requestParameters.createManyTransferDto was null or undefined when calling createManyBaseTransferControllerTransfer."
      );
    }
  }

  /**
   * Create multiple Transfers
   */
  private createManyBaseTransferControllerTransferContext(
    requestParameters: CreateManyBaseTransferControllerTransferRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/transfer/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyTransferDtoToJSON(requestParameters.createManyTransferDto)
    };
  }

  /**
   * Create multiple Transfers
   */
  createManyBaseTransferControllerTransfer = async (
    createManyTransferDto: CreateManyTransferDto
  ): Promise<Array<Transfer>> => {
    const response = await this.createManyBaseTransferControllerTransferRaw({
      createManyTransferDto: createManyTransferDto
    });
    return await response.value();
  };

  /**
   * Create multiple Warehouses
   */
  private async createManyBaseWarehouseControllerWarehouseRaw(
    requestParameters: CreateManyBaseWarehouseControllerWarehouseRequest
  ): Promise<runtime.ApiResponse<Array<Warehouse>>> {
    this.createManyBaseWarehouseControllerWarehouseValidation(requestParameters);
    const context = this.createManyBaseWarehouseControllerWarehouseContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(WarehouseFromJSON));
  }

  /**
   * Create multiple Warehouses
   */
  private createManyBaseWarehouseControllerWarehouseValidation(
    requestParameters: CreateManyBaseWarehouseControllerWarehouseRequest
  ) {
    if (requestParameters.createManyWarehouseDto === null || requestParameters.createManyWarehouseDto === undefined) {
      throw new runtime.RequiredError(
        "createManyWarehouseDto",
        "Required parameter requestParameters.createManyWarehouseDto was null or undefined when calling createManyBaseWarehouseControllerWarehouse."
      );
    }
  }

  /**
   * Create multiple Warehouses
   */
  private createManyBaseWarehouseControllerWarehouseContext(
    requestParameters: CreateManyBaseWarehouseControllerWarehouseRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/warehouse/bulk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateManyWarehouseDtoToJSON(requestParameters.createManyWarehouseDto)
    };
  }

  /**
   * Create multiple Warehouses
   */
  createManyBaseWarehouseControllerWarehouse = async (
    createManyWarehouseDto: CreateManyWarehouseDto
  ): Promise<Array<Warehouse>> => {
    const response = await this.createManyBaseWarehouseControllerWarehouseRaw({
      createManyWarehouseDto: createManyWarehouseDto
    });
    return await response.value();
  };

  /**
   * Create a single Asset
   */
  private async createOneBaseAssetControllerAssetRaw(
    requestParameters: CreateOneBaseAssetControllerAssetRequest
  ): Promise<runtime.ApiResponse<Asset>> {
    this.createOneBaseAssetControllerAssetValidation(requestParameters);
    const context = this.createOneBaseAssetControllerAssetContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => AssetFromJSON(jsonValue));
  }

  /**
   * Create a single Asset
   */
  private createOneBaseAssetControllerAssetValidation(requestParameters: CreateOneBaseAssetControllerAssetRequest) {
    if (requestParameters.assetDto === null || requestParameters.assetDto === undefined) {
      throw new runtime.RequiredError(
        "assetDto",
        "Required parameter requestParameters.assetDto was null or undefined when calling createOneBaseAssetControllerAsset."
      );
    }
  }

  /**
   * Create a single Asset
   */
  private createOneBaseAssetControllerAssetContext(
    requestParameters: CreateOneBaseAssetControllerAssetRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AssetDtoToJSON(requestParameters.assetDto)
    };
  }

  /**
   * Create a single Asset
   */
  createOneBaseAssetControllerAsset = async (assetDto: AssetDto): Promise<Asset> => {
    const response = await this.createOneBaseAssetControllerAssetRaw({ assetDto: assetDto });
    return await response.value();
  };

  /**
   * Create a single Disk
   */
  private async createOneBaseDiskControllerDiskRaw(
    requestParameters: CreateOneBaseDiskControllerDiskRequest
  ): Promise<runtime.ApiResponse<Disk>> {
    this.createOneBaseDiskControllerDiskValidation(requestParameters);
    const context = this.createOneBaseDiskControllerDiskContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => DiskFromJSON(jsonValue));
  }

  /**
   * Create a single Disk
   */
  private createOneBaseDiskControllerDiskValidation(requestParameters: CreateOneBaseDiskControllerDiskRequest) {
    if (requestParameters.diskDto === null || requestParameters.diskDto === undefined) {
      throw new runtime.RequiredError(
        "diskDto",
        "Required parameter requestParameters.diskDto was null or undefined when calling createOneBaseDiskControllerDisk."
      );
    }
  }

  /**
   * Create a single Disk
   */
  private createOneBaseDiskControllerDiskContext(
    requestParameters: CreateOneBaseDiskControllerDiskRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/disk`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: DiskDtoToJSON(requestParameters.diskDto)
    };
  }

  /**
   * Create a single Disk
   */
  createOneBaseDiskControllerDisk = async (diskDto: DiskDto): Promise<Disk> => {
    const response = await this.createOneBaseDiskControllerDiskRaw({ diskDto: diskDto });
    return await response.value();
  };

  /**
   * Create a single Manufacturer
   */
  private async createOneBaseManufacturerControllerManufacturerRaw(
    requestParameters: CreateOneBaseManufacturerControllerManufacturerRequest
  ): Promise<runtime.ApiResponse<Manufacturer>> {
    this.createOneBaseManufacturerControllerManufacturerValidation(requestParameters);
    const context = this.createOneBaseManufacturerControllerManufacturerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ManufacturerFromJSON(jsonValue));
  }

  /**
   * Create a single Manufacturer
   */
  private createOneBaseManufacturerControllerManufacturerValidation(
    requestParameters: CreateOneBaseManufacturerControllerManufacturerRequest
  ) {
    if (requestParameters.manufacturerDto === null || requestParameters.manufacturerDto === undefined) {
      throw new runtime.RequiredError(
        "manufacturerDto",
        "Required parameter requestParameters.manufacturerDto was null or undefined when calling createOneBaseManufacturerControllerManufacturer."
      );
    }
  }

  /**
   * Create a single Manufacturer
   */
  private createOneBaseManufacturerControllerManufacturerContext(
    requestParameters: CreateOneBaseManufacturerControllerManufacturerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/manufacturer`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ManufacturerDtoToJSON(requestParameters.manufacturerDto)
    };
  }

  /**
   * Create a single Manufacturer
   */
  createOneBaseManufacturerControllerManufacturer = async (manufacturerDto: ManufacturerDto): Promise<Manufacturer> => {
    const response = await this.createOneBaseManufacturerControllerManufacturerRaw({
      manufacturerDto: manufacturerDto
    });
    return await response.value();
  };

  /**
   * Create a single NetworkInterface
   */
  private async createOneBaseNetworkInterfaceControllerNetworkInterfaceRaw(
    requestParameters: CreateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ): Promise<runtime.ApiResponse<NetworkInterface>> {
    this.createOneBaseNetworkInterfaceControllerNetworkInterfaceValidation(requestParameters);
    const context = this.createOneBaseNetworkInterfaceControllerNetworkInterfaceContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => NetworkInterfaceFromJSON(jsonValue));
  }

  /**
   * Create a single NetworkInterface
   */
  private createOneBaseNetworkInterfaceControllerNetworkInterfaceValidation(
    requestParameters: CreateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ) {
    if (requestParameters.networkInterfaceDto === null || requestParameters.networkInterfaceDto === undefined) {
      throw new runtime.RequiredError(
        "networkInterfaceDto",
        "Required parameter requestParameters.networkInterfaceDto was null or undefined when calling createOneBaseNetworkInterfaceControllerNetworkInterface."
      );
    }
  }

  /**
   * Create a single NetworkInterface
   */
  private createOneBaseNetworkInterfaceControllerNetworkInterfaceContext(
    requestParameters: CreateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/network-interface`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: NetworkInterfaceDtoToJSON(requestParameters.networkInterfaceDto)
    };
  }

  /**
   * Create a single NetworkInterface
   */
  createOneBaseNetworkInterfaceControllerNetworkInterface = async (
    networkInterfaceDto: NetworkInterfaceDto
  ): Promise<NetworkInterface> => {
    const response = await this.createOneBaseNetworkInterfaceControllerNetworkInterfaceRaw({
      networkInterfaceDto: networkInterfaceDto
    });
    return await response.value();
  };

  /**
   * Create a single Platform
   */
  private async createOneBasePlatformControllerPlatformRaw(
    requestParameters: CreateOneBasePlatformControllerPlatformRequest
  ): Promise<runtime.ApiResponse<Platform>> {
    this.createOneBasePlatformControllerPlatformValidation(requestParameters);
    const context = this.createOneBasePlatformControllerPlatformContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PlatformFromJSON(jsonValue));
  }

  /**
   * Create a single Platform
   */
  private createOneBasePlatformControllerPlatformValidation(
    requestParameters: CreateOneBasePlatformControllerPlatformRequest
  ) {
    if (requestParameters.platformDto === null || requestParameters.platformDto === undefined) {
      throw new runtime.RequiredError(
        "platformDto",
        "Required parameter requestParameters.platformDto was null or undefined when calling createOneBasePlatformControllerPlatform."
      );
    }
  }

  /**
   * Create a single Platform
   */
  private createOneBasePlatformControllerPlatformContext(
    requestParameters: CreateOneBasePlatformControllerPlatformRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/platform`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PlatformDtoToJSON(requestParameters.platformDto)
    };
  }

  /**
   * Create a single Platform
   */
  createOneBasePlatformControllerPlatform = async (platformDto: PlatformDto): Promise<Platform> => {
    const response = await this.createOneBasePlatformControllerPlatformRaw({ platformDto: platformDto });
    return await response.value();
  };

  /**
   * Create a single PowerUnit
   */
  private async createOneBasePowerUnitControllerPowerUnitRaw(
    requestParameters: CreateOneBasePowerUnitControllerPowerUnitRequest
  ): Promise<runtime.ApiResponse<PowerUnit>> {
    this.createOneBasePowerUnitControllerPowerUnitValidation(requestParameters);
    const context = this.createOneBasePowerUnitControllerPowerUnitContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PowerUnitFromJSON(jsonValue));
  }

  /**
   * Create a single PowerUnit
   */
  private createOneBasePowerUnitControllerPowerUnitValidation(
    requestParameters: CreateOneBasePowerUnitControllerPowerUnitRequest
  ) {
    if (requestParameters.powerUnitDto === null || requestParameters.powerUnitDto === undefined) {
      throw new runtime.RequiredError(
        "powerUnitDto",
        "Required parameter requestParameters.powerUnitDto was null or undefined when calling createOneBasePowerUnitControllerPowerUnit."
      );
    }
  }

  /**
   * Create a single PowerUnit
   */
  private createOneBasePowerUnitControllerPowerUnitContext(
    requestParameters: CreateOneBasePowerUnitControllerPowerUnitRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/power-unit`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PowerUnitDtoToJSON(requestParameters.powerUnitDto)
    };
  }

  /**
   * Create a single PowerUnit
   */
  createOneBasePowerUnitControllerPowerUnit = async (powerUnitDto: PowerUnitDto): Promise<PowerUnit> => {
    const response = await this.createOneBasePowerUnitControllerPowerUnitRaw({ powerUnitDto: powerUnitDto });
    return await response.value();
  };

  /**
   * Create a single Processor
   */
  private async createOneBaseProcessorControllerProcessorRaw(
    requestParameters: CreateOneBaseProcessorControllerProcessorRequest
  ): Promise<runtime.ApiResponse<Processor>> {
    this.createOneBaseProcessorControllerProcessorValidation(requestParameters);
    const context = this.createOneBaseProcessorControllerProcessorContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ProcessorFromJSON(jsonValue));
  }

  /**
   * Create a single Processor
   */
  private createOneBaseProcessorControllerProcessorValidation(
    requestParameters: CreateOneBaseProcessorControllerProcessorRequest
  ) {
    if (requestParameters.processorDto === null || requestParameters.processorDto === undefined) {
      throw new runtime.RequiredError(
        "processorDto",
        "Required parameter requestParameters.processorDto was null or undefined when calling createOneBaseProcessorControllerProcessor."
      );
    }
  }

  /**
   * Create a single Processor
   */
  private createOneBaseProcessorControllerProcessorContext(
    requestParameters: CreateOneBaseProcessorControllerProcessorRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/processor`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ProcessorDtoToJSON(requestParameters.processorDto)
    };
  }

  /**
   * Create a single Processor
   */
  createOneBaseProcessorControllerProcessor = async (processorDto: ProcessorDto): Promise<Processor> => {
    const response = await this.createOneBaseProcessorControllerProcessorRaw({ processorDto: processorDto });
    return await response.value();
  };

  /**
   * Create a single RAIDController
   */
  private async createOneBaseRAIDControllerControllerRAIDControllerRaw(
    requestParameters: CreateOneBaseRAIDControllerControllerRAIDControllerRequest
  ): Promise<runtime.ApiResponse<RAIDController>> {
    this.createOneBaseRAIDControllerControllerRAIDControllerValidation(requestParameters);
    const context = this.createOneBaseRAIDControllerControllerRAIDControllerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => RAIDControllerFromJSON(jsonValue));
  }

  /**
   * Create a single RAIDController
   */
  private createOneBaseRAIDControllerControllerRAIDControllerValidation(
    requestParameters: CreateOneBaseRAIDControllerControllerRAIDControllerRequest
  ) {
    if (requestParameters.rAIDControllerDto === null || requestParameters.rAIDControllerDto === undefined) {
      throw new runtime.RequiredError(
        "rAIDControllerDto",
        "Required parameter requestParameters.rAIDControllerDto was null or undefined when calling createOneBaseRAIDControllerControllerRAIDController."
      );
    }
  }

  /**
   * Create a single RAIDController
   */
  private createOneBaseRAIDControllerControllerRAIDControllerContext(
    requestParameters: CreateOneBaseRAIDControllerControllerRAIDControllerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/raid-controller`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RAIDControllerDtoToJSON(requestParameters.rAIDControllerDto)
    };
  }

  /**
   * Create a single RAIDController
   */
  createOneBaseRAIDControllerControllerRAIDController = async (
    rAIDControllerDto: RAIDControllerDto
  ): Promise<RAIDController> => {
    const response = await this.createOneBaseRAIDControllerControllerRAIDControllerRaw({
      rAIDControllerDto: rAIDControllerDto
    });
    return await response.value();
  };

  /**
   * Create a single RAM
   */
  private async createOneBaseRAMControllerRAMRaw(
    requestParameters: CreateOneBaseRAMControllerRAMRequest
  ): Promise<runtime.ApiResponse<RAM>> {
    this.createOneBaseRAMControllerRAMValidation(requestParameters);
    const context = this.createOneBaseRAMControllerRAMContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => RAMFromJSON(jsonValue));
  }

  /**
   * Create a single RAM
   */
  private createOneBaseRAMControllerRAMValidation(requestParameters: CreateOneBaseRAMControllerRAMRequest) {
    if (requestParameters.rAMDto === null || requestParameters.rAMDto === undefined) {
      throw new runtime.RequiredError(
        "rAMDto",
        "Required parameter requestParameters.rAMDto was null or undefined when calling createOneBaseRAMControllerRAM."
      );
    }
  }

  /**
   * Create a single RAM
   */
  private createOneBaseRAMControllerRAMContext(
    requestParameters: CreateOneBaseRAMControllerRAMRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/ram`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RAMDtoToJSON(requestParameters.rAMDto)
    };
  }

  /**
   * Create a single RAM
   */
  createOneBaseRAMControllerRAM = async (rAMDto: RAMDto): Promise<RAM> => {
    const response = await this.createOneBaseRAMControllerRAMRaw({ rAMDto: rAMDto });
    return await response.value();
  };

  /**
   * Create a single Switch
   */
  private async createOneBaseSwitchControllerSwitchRaw(
    requestParameters: CreateOneBaseSwitchControllerSwitchRequest
  ): Promise<runtime.ApiResponse<Switch>> {
    this.createOneBaseSwitchControllerSwitchValidation(requestParameters);
    const context = this.createOneBaseSwitchControllerSwitchContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => SwitchFromJSON(jsonValue));
  }

  /**
   * Create a single Switch
   */
  private createOneBaseSwitchControllerSwitchValidation(requestParameters: CreateOneBaseSwitchControllerSwitchRequest) {
    if (requestParameters.switchDto === null || requestParameters.switchDto === undefined) {
      throw new runtime.RequiredError(
        "switchDto",
        "Required parameter requestParameters.switchDto was null or undefined when calling createOneBaseSwitchControllerSwitch."
      );
    }
  }

  /**
   * Create a single Switch
   */
  private createOneBaseSwitchControllerSwitchContext(
    requestParameters: CreateOneBaseSwitchControllerSwitchRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/switch`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SwitchDtoToJSON(requestParameters.switchDto)
    };
  }

  /**
   * Create a single Switch
   */
  createOneBaseSwitchControllerSwitch = async (switchDto: SwitchDto): Promise<Switch> => {
    const response = await this.createOneBaseSwitchControllerSwitchRaw({ switchDto: switchDto });
    return await response.value();
  };

  /**
   * Create a single Ticket
   */
  private async createOneBaseTicketControllerTicketRaw(
    requestParameters: CreateOneBaseTicketControllerTicketRequest
  ): Promise<runtime.ApiResponse<Ticket>> {
    this.createOneBaseTicketControllerTicketValidation(requestParameters);
    const context = this.createOneBaseTicketControllerTicketContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TicketFromJSON(jsonValue));
  }

  /**
   * Create a single Ticket
   */
  private createOneBaseTicketControllerTicketValidation(requestParameters: CreateOneBaseTicketControllerTicketRequest) {
    if (requestParameters.ticketDto === null || requestParameters.ticketDto === undefined) {
      throw new runtime.RequiredError(
        "ticketDto",
        "Required parameter requestParameters.ticketDto was null or undefined when calling createOneBaseTicketControllerTicket."
      );
    }
  }

  /**
   * Create a single Ticket
   */
  private createOneBaseTicketControllerTicketContext(
    requestParameters: CreateOneBaseTicketControllerTicketRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TicketDtoToJSON(requestParameters.ticketDto)
    };
  }

  /**
   * Create a single Ticket
   */
  createOneBaseTicketControllerTicket = async (ticketDto: TicketDto): Promise<Ticket> => {
    const response = await this.createOneBaseTicketControllerTicketRaw({ ticketDto: ticketDto });
    return await response.value();
  };

  /**
   * Create a single Transfer
   */
  private async createOneBaseTransferControllerTransferRaw(
    requestParameters: CreateOneBaseTransferControllerTransferRequest
  ): Promise<runtime.ApiResponse<Transfer>> {
    this.createOneBaseTransferControllerTransferValidation(requestParameters);
    const context = this.createOneBaseTransferControllerTransferContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TransferFromJSON(jsonValue));
  }

  /**
   * Create a single Transfer
   */
  private createOneBaseTransferControllerTransferValidation(
    requestParameters: CreateOneBaseTransferControllerTransferRequest
  ) {
    if (requestParameters.transferDto === null || requestParameters.transferDto === undefined) {
      throw new runtime.RequiredError(
        "transferDto",
        "Required parameter requestParameters.transferDto was null or undefined when calling createOneBaseTransferControllerTransfer."
      );
    }
  }

  /**
   * Create a single Transfer
   */
  private createOneBaseTransferControllerTransferContext(
    requestParameters: CreateOneBaseTransferControllerTransferRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/transfer`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TransferDtoToJSON(requestParameters.transferDto)
    };
  }

  /**
   * Create a single Transfer
   */
  createOneBaseTransferControllerTransfer = async (transferDto: TransferDto): Promise<Transfer> => {
    const response = await this.createOneBaseTransferControllerTransferRaw({ transferDto: transferDto });
    return await response.value();
  };

  /**
   * Create a single Warehouse
   */
  private async createOneBaseWarehouseControllerWarehouseRaw(
    requestParameters: CreateOneBaseWarehouseControllerWarehouseRequest
  ): Promise<runtime.ApiResponse<Warehouse>> {
    this.createOneBaseWarehouseControllerWarehouseValidation(requestParameters);
    const context = this.createOneBaseWarehouseControllerWarehouseContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => WarehouseFromJSON(jsonValue));
  }

  /**
   * Create a single Warehouse
   */
  private createOneBaseWarehouseControllerWarehouseValidation(
    requestParameters: CreateOneBaseWarehouseControllerWarehouseRequest
  ) {
    if (requestParameters.warehouseDto === null || requestParameters.warehouseDto === undefined) {
      throw new runtime.RequiredError(
        "warehouseDto",
        "Required parameter requestParameters.warehouseDto was null or undefined when calling createOneBaseWarehouseControllerWarehouse."
      );
    }
  }

  /**
   * Create a single Warehouse
   */
  private createOneBaseWarehouseControllerWarehouseContext(
    requestParameters: CreateOneBaseWarehouseControllerWarehouseRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/warehouse`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: WarehouseDtoToJSON(requestParameters.warehouseDto)
    };
  }

  /**
   * Create a single Warehouse
   */
  createOneBaseWarehouseControllerWarehouse = async (warehouseDto: WarehouseDto): Promise<Warehouse> => {
    const response = await this.createOneBaseWarehouseControllerWarehouseRaw({ warehouseDto: warehouseDto });
    return await response.value();
  };

  /**
   */
  private async createServerRaw(requestParameters: CreateServerRequest): Promise<runtime.ApiResponse<Server>> {
    this.createServerValidation(requestParameters);
    const context = this.createServerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ServerFromJSON(jsonValue));
  }

  /**
   */
  private createServerValidation(requestParameters: CreateServerRequest) {
    if (requestParameters.createUpdateServerDto === null || requestParameters.createUpdateServerDto === undefined) {
      throw new runtime.RequiredError(
        "createUpdateServerDto",
        "Required parameter requestParameters.createUpdateServerDto was null or undefined when calling createServer."
      );
    }
  }

  /**
   */
  private createServerContext(requestParameters: CreateServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateUpdateServerDtoToJSON(requestParameters.createUpdateServerDto)
    };
  }

  /**
   */
  createServer = async (createUpdateServerDto: CreateUpdateServerDto): Promise<Server> => {
    const response = await this.createServerRaw({ createUpdateServerDto: createUpdateServerDto });
    return await response.value();
  };

  /**
   */
  private async deleteAssignmentRaw(requestParameters: DeleteAssignmentRequest): Promise<runtime.ApiResponse<object>> {
    this.deleteAssignmentValidation(requestParameters);
    const context = this.deleteAssignmentContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private deleteAssignmentValidation(requestParameters: DeleteAssignmentRequest) {
    if (requestParameters.transferId === null || requestParameters.transferId === undefined) {
      throw new runtime.RequiredError(
        "transferId",
        "Required parameter requestParameters.transferId was null or undefined when calling deleteAssignment."
      );
    }
    if (requestParameters.assignmentId === null || requestParameters.assignmentId === undefined) {
      throw new runtime.RequiredError(
        "assignmentId",
        "Required parameter requestParameters.assignmentId was null or undefined when calling deleteAssignment."
      );
    }
  }

  /**
   */
  private deleteAssignmentContext(requestParameters: DeleteAssignmentRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/transfer/{transferId}/assignments/{assignmentId}`
        .replace(`{${"transferId"}}`, encodeURIComponent(String(requestParameters.transferId)))
        .replace(`{${"assignmentId"}}`, encodeURIComponent(String(requestParameters.assignmentId))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  deleteAssignment = async (transferId: string, assignmentId: string): Promise<object> => {
    const response = await this.deleteAssignmentRaw({ transferId: transferId, assignmentId: assignmentId });
    return await response.value();
  };

  useDeleteAssignment(transferId: string, assignmentId: string, config?: ConfigInterface<object, Error>) {
    let valid = true;

    if (transferId === null || transferId === undefined || Number.isNaN(transferId)) {
      valid = false;
    }

    if (assignmentId === null || assignmentId === undefined || Number.isNaN(assignmentId)) {
      valid = false;
    }

    const context = this.deleteAssignmentContext({ transferId: transferId!, assignmentId: assignmentId! });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.deleteAssignment(transferId!, assignmentId!) : undefined,
      config
    );
  }

  /**
   * Delete a single Asset
   */
  private async deleteOneBaseAssetControllerAssetRaw(
    requestParameters: DeleteOneBaseAssetControllerAssetRequest
  ): Promise<runtime.ApiResponse<void>> {
    this.deleteOneBaseAssetControllerAssetValidation(requestParameters);
    const context = this.deleteOneBaseAssetControllerAssetContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a single Asset
   */
  private deleteOneBaseAssetControllerAssetValidation(requestParameters: DeleteOneBaseAssetControllerAssetRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteOneBaseAssetControllerAsset."
      );
    }
  }

  /**
   * Delete a single Asset
   */
  private deleteOneBaseAssetControllerAssetContext(
    requestParameters: DeleteOneBaseAssetControllerAssetRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Delete a single Asset
   */
  deleteOneBaseAssetControllerAsset = async (id: string): Promise<void> => {
    await this.deleteOneBaseAssetControllerAssetRaw({ id: id });
  };

  useDeleteOneBaseAssetControllerAsset(id: string, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.deleteOneBaseAssetControllerAssetContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.deleteOneBaseAssetControllerAsset(id!) : undefined,
      config
    );
  }

  /**
   * Delete a single Manufacturer
   */
  private async deleteOneBaseManufacturerControllerManufacturerRaw(
    requestParameters: DeleteOneBaseManufacturerControllerManufacturerRequest
  ): Promise<runtime.ApiResponse<void>> {
    this.deleteOneBaseManufacturerControllerManufacturerValidation(requestParameters);
    const context = this.deleteOneBaseManufacturerControllerManufacturerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a single Manufacturer
   */
  private deleteOneBaseManufacturerControllerManufacturerValidation(
    requestParameters: DeleteOneBaseManufacturerControllerManufacturerRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteOneBaseManufacturerControllerManufacturer."
      );
    }
  }

  /**
   * Delete a single Manufacturer
   */
  private deleteOneBaseManufacturerControllerManufacturerContext(
    requestParameters: DeleteOneBaseManufacturerControllerManufacturerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/manufacturer/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Delete a single Manufacturer
   */
  deleteOneBaseManufacturerControllerManufacturer = async (id: string): Promise<void> => {
    await this.deleteOneBaseManufacturerControllerManufacturerRaw({ id: id });
  };

  useDeleteOneBaseManufacturerControllerManufacturer(id: string, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.deleteOneBaseManufacturerControllerManufacturerContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.deleteOneBaseManufacturerControllerManufacturer(id!) : undefined,
      config
    );
  }

  /**
   * Delete a single Model
   */
  private async deleteOneBaseModelControllerModelRaw(
    requestParameters: DeleteOneBaseModelControllerModelRequest
  ): Promise<runtime.ApiResponse<void>> {
    this.deleteOneBaseModelControllerModelValidation(requestParameters);
    const context = this.deleteOneBaseModelControllerModelContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a single Model
   */
  private deleteOneBaseModelControllerModelValidation(requestParameters: DeleteOneBaseModelControllerModelRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteOneBaseModelControllerModel."
      );
    }
  }

  /**
   * Delete a single Model
   */
  private deleteOneBaseModelControllerModelContext(
    requestParameters: DeleteOneBaseModelControllerModelRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Delete a single Model
   */
  deleteOneBaseModelControllerModel = async (id: string): Promise<void> => {
    await this.deleteOneBaseModelControllerModelRaw({ id: id });
  };

  useDeleteOneBaseModelControllerModel(id: string, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.deleteOneBaseModelControllerModelContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.deleteOneBaseModelControllerModel(id!) : undefined,
      config
    );
  }

  /**
   * Delete a single Ticket
   */
  private async deleteOneBaseTicketControllerTicketRaw(
    requestParameters: DeleteOneBaseTicketControllerTicketRequest
  ): Promise<runtime.ApiResponse<void>> {
    this.deleteOneBaseTicketControllerTicketValidation(requestParameters);
    const context = this.deleteOneBaseTicketControllerTicketContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a single Ticket
   */
  private deleteOneBaseTicketControllerTicketValidation(requestParameters: DeleteOneBaseTicketControllerTicketRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteOneBaseTicketControllerTicket."
      );
    }
  }

  /**
   * Delete a single Ticket
   */
  private deleteOneBaseTicketControllerTicketContext(
    requestParameters: DeleteOneBaseTicketControllerTicketRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Delete a single Ticket
   */
  deleteOneBaseTicketControllerTicket = async (id: number): Promise<void> => {
    await this.deleteOneBaseTicketControllerTicketRaw({ id: id });
  };

  useDeleteOneBaseTicketControllerTicket(id: number, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.deleteOneBaseTicketControllerTicketContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.deleteOneBaseTicketControllerTicket(id!) : undefined,
      config
    );
  }

  /**
   * Delete a single Transfer
   */
  private async deleteOneBaseTransferControllerTransferRaw(
    requestParameters: DeleteOneBaseTransferControllerTransferRequest
  ): Promise<runtime.ApiResponse<void>> {
    this.deleteOneBaseTransferControllerTransferValidation(requestParameters);
    const context = this.deleteOneBaseTransferControllerTransferContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a single Transfer
   */
  private deleteOneBaseTransferControllerTransferValidation(
    requestParameters: DeleteOneBaseTransferControllerTransferRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteOneBaseTransferControllerTransfer."
      );
    }
  }

  /**
   * Delete a single Transfer
   */
  private deleteOneBaseTransferControllerTransferContext(
    requestParameters: DeleteOneBaseTransferControllerTransferRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/transfer/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Delete a single Transfer
   */
  deleteOneBaseTransferControllerTransfer = async (id: string): Promise<void> => {
    await this.deleteOneBaseTransferControllerTransferRaw({ id: id });
  };

  useDeleteOneBaseTransferControllerTransfer(id: string, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.deleteOneBaseTransferControllerTransferContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.deleteOneBaseTransferControllerTransfer(id!) : undefined,
      config
    );
  }

  /**
   * Delete a single Warehouse
   */
  private async deleteOneBaseWarehouseControllerWarehouseRaw(
    requestParameters: DeleteOneBaseWarehouseControllerWarehouseRequest
  ): Promise<runtime.ApiResponse<void>> {
    this.deleteOneBaseWarehouseControllerWarehouseValidation(requestParameters);
    const context = this.deleteOneBaseWarehouseControllerWarehouseContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a single Warehouse
   */
  private deleteOneBaseWarehouseControllerWarehouseValidation(
    requestParameters: DeleteOneBaseWarehouseControllerWarehouseRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteOneBaseWarehouseControllerWarehouse."
      );
    }
  }

  /**
   * Delete a single Warehouse
   */
  private deleteOneBaseWarehouseControllerWarehouseContext(
    requestParameters: DeleteOneBaseWarehouseControllerWarehouseRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/warehouse/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Delete a single Warehouse
   */
  deleteOneBaseWarehouseControllerWarehouse = async (id: string): Promise<void> => {
    await this.deleteOneBaseWarehouseControllerWarehouseRaw({ id: id });
  };

  useDeleteOneBaseWarehouseControllerWarehouse(id: string, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.deleteOneBaseWarehouseControllerWarehouseContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.deleteOneBaseWarehouseControllerWarehouse(id!) : undefined,
      config
    );
  }

  /**
   */
  private async deleteServerRaw(requestParameters: DeleteServerRequest): Promise<runtime.ApiResponse<void>> {
    this.deleteServerValidation(requestParameters);
    const context = this.deleteServerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private deleteServerValidation(requestParameters: DeleteServerRequest) {
    if (requestParameters.serverId === null || requestParameters.serverId === undefined) {
      throw new runtime.RequiredError(
        "serverId",
        "Required parameter requestParameters.serverId was null or undefined when calling deleteServer."
      );
    }
  }

  /**
   */
  private deleteServerContext(requestParameters: DeleteServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{serverId}`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(requestParameters.serverId))
      ),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  deleteServer = async (serverId: number): Promise<void> => {
    await this.deleteServerRaw({ serverId: serverId });
  };

  useDeleteServer(serverId: number, config?: ConfigInterface<void, Error>) {
    let valid = true;

    if (serverId === null || serverId === undefined || Number.isNaN(serverId)) {
      valid = false;
    }

    const context = this.deleteServerContext({ serverId: serverId! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.deleteServer(serverId!) : undefined, config);
  }

  /**
   */
  private async deployServerRaw(requestParameters: DeployServerRequest): Promise<runtime.ApiResponse<void>> {
    this.deployServerValidation(requestParameters);
    const context = this.deployServerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private deployServerValidation(requestParameters: DeployServerRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deployServer."
      );
    }
    if (requestParameters.deployServerDto === null || requestParameters.deployServerDto === undefined) {
      throw new runtime.RequiredError(
        "deployServerDto",
        "Required parameter requestParameters.deployServerDto was null or undefined when calling deployServer."
      );
    }
  }

  /**
   */
  private deployServerContext(requestParameters: DeployServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/deploy`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: DeployServerDtoToJSON(requestParameters.deployServerDto)
    };
  }

  /**
   */
  deployServer = async (id: number, deployServerDto: DeployServerDto): Promise<void> => {
    await this.deployServerRaw({ id: id, deployServerDto: deployServerDto });
  };

  /**
   */
  private async freeIPAddressRaw(
    requestParameters: FreeIPAddressRequest
  ): Promise<runtime.ApiResponse<FreeAddressDto>> {
    this.freeIPAddressValidation(requestParameters);
    const context = this.freeIPAddressContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => FreeAddressDtoFromJSON(jsonValue));
  }

  /**
   */
  private freeIPAddressValidation(requestParameters: FreeIPAddressRequest) {
    if (requestParameters.prefixId === null || requestParameters.prefixId === undefined) {
      throw new runtime.RequiredError(
        "prefixId",
        "Required parameter requestParameters.prefixId was null or undefined when calling freeIPAddress."
      );
    }
  }

  /**
   */
  private freeIPAddressContext(requestParameters: FreeIPAddressRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/address/{prefixId}/available-ip`.replace(
        `{${"prefixId"}}`,
        encodeURIComponent(String(requestParameters.prefixId))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  freeIPAddress = async (prefixId: number): Promise<FreeAddressDto> => {
    const response = await this.freeIPAddressRaw({ prefixId: prefixId });
    return await response.value();
  };

  useFreeIPAddress(prefixId: number, config?: ConfigInterface<FreeAddressDto, Error>) {
    let valid = true;

    if (prefixId === null || prefixId === undefined || Number.isNaN(prefixId)) {
      valid = false;
    }

    const context = this.freeIPAddressContext({ prefixId: prefixId! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.freeIPAddress(prefixId!) : undefined, config);
  }

  /**
   * Retrieve multiple Assets
   */
  private async getManyBaseAssetControllerAssetRaw(
    requestParameters: GetManyBaseAssetControllerAssetRequest
  ): Promise<runtime.ApiResponse<Array<object>>> {
    this.getManyBaseAssetControllerAssetValidation(requestParameters);
    const context = this.getManyBaseAssetControllerAssetContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve multiple Assets
   */
  private getManyBaseAssetControllerAssetValidation(requestParameters: GetManyBaseAssetControllerAssetRequest) {}

  /**
   * Retrieve multiple Assets
   */
  private getManyBaseAssetControllerAssetContext(
    requestParameters: GetManyBaseAssetControllerAssetRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.s !== undefined) {
      queryParameters["s"] = requestParameters.s;
    }

    if (requestParameters.filter) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.or) {
      queryParameters["or"] = requestParameters.or;
    }

    if (requestParameters.sort) {
      queryParameters["sort"] = requestParameters.sort;
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    if (requestParameters.offset !== undefined) {
      queryParameters["offset"] = requestParameters.offset;
    }

    if (requestParameters.page !== undefined) {
      queryParameters["page"] = requestParameters.page;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve multiple Assets
   */
  getManyBaseAssetControllerAsset = async (
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number
  ): Promise<Array<object>> => {
    const response = await this.getManyBaseAssetControllerAssetRaw({
      fields: fields,
      s: s,
      filter: filter,
      or: or,
      sort: sort,
      join: join,
      limit: limit,
      offset: offset,
      page: page,
      cache: cache
    });
    return await response.value();
  };

  useGetManyBaseAssetControllerAsset(
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number,
    config?: ConfigInterface<Array<object>, Error>
  ) {
    let valid = true;

    const context = this.getManyBaseAssetControllerAssetContext({
      fields: fields!,
      s: s!,
      filter: filter!,
      or: or!,
      sort: sort!,
      join: join!,
      limit: limit!,
      offset: offset!,
      page: page!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid
        ? () =>
            this.getManyBaseAssetControllerAsset(
              fields!,
              s!,
              filter!,
              or!,
              sort!,
              join!,
              limit!,
              offset!,
              page!,
              cache!
            )
        : undefined,
      config
    );
  }

  /**
   * Retrieve multiple Manufacturers
   */
  private async getManyBaseManufacturerControllerManufacturerRaw(
    requestParameters: GetManyBaseManufacturerControllerManufacturerRequest
  ): Promise<runtime.ApiResponse<Array<Manufacturer>>> {
    this.getManyBaseManufacturerControllerManufacturerValidation(requestParameters);
    const context = this.getManyBaseManufacturerControllerManufacturerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(ManufacturerFromJSON));
  }

  /**
   * Retrieve multiple Manufacturers
   */
  private getManyBaseManufacturerControllerManufacturerValidation(
    requestParameters: GetManyBaseManufacturerControllerManufacturerRequest
  ) {}

  /**
   * Retrieve multiple Manufacturers
   */
  private getManyBaseManufacturerControllerManufacturerContext(
    requestParameters: GetManyBaseManufacturerControllerManufacturerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.s !== undefined) {
      queryParameters["s"] = requestParameters.s;
    }

    if (requestParameters.filter) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.or) {
      queryParameters["or"] = requestParameters.or;
    }

    if (requestParameters.sort) {
      queryParameters["sort"] = requestParameters.sort;
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    if (requestParameters.offset !== undefined) {
      queryParameters["offset"] = requestParameters.offset;
    }

    if (requestParameters.page !== undefined) {
      queryParameters["page"] = requestParameters.page;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/manufacturer`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve multiple Manufacturers
   */
  getManyBaseManufacturerControllerManufacturer = async (
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number
  ): Promise<Array<Manufacturer>> => {
    const response = await this.getManyBaseManufacturerControllerManufacturerRaw({
      fields: fields,
      s: s,
      filter: filter,
      or: or,
      sort: sort,
      join: join,
      limit: limit,
      offset: offset,
      page: page,
      cache: cache
    });
    return await response.value();
  };

  useGetManyBaseManufacturerControllerManufacturer(
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number,
    config?: ConfigInterface<Array<Manufacturer>, Error>
  ) {
    let valid = true;

    const context = this.getManyBaseManufacturerControllerManufacturerContext({
      fields: fields!,
      s: s!,
      filter: filter!,
      or: or!,
      sort: sort!,
      join: join!,
      limit: limit!,
      offset: offset!,
      page: page!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid
        ? () =>
            this.getManyBaseManufacturerControllerManufacturer(
              fields!,
              s!,
              filter!,
              or!,
              sort!,
              join!,
              limit!,
              offset!,
              page!,
              cache!
            )
        : undefined,
      config
    );
  }

  /**
   * Retrieve multiple Models
   */
  private async getManyBaseModelControllerModelRaw(
    requestParameters: GetManyBaseModelControllerModelRequest
  ): Promise<runtime.ApiResponse<Array<object>>> {
    this.getManyBaseModelControllerModelValidation(requestParameters);
    const context = this.getManyBaseModelControllerModelContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve multiple Models
   */
  private getManyBaseModelControllerModelValidation(requestParameters: GetManyBaseModelControllerModelRequest) {}

  /**
   * Retrieve multiple Models
   */
  private getManyBaseModelControllerModelContext(
    requestParameters: GetManyBaseModelControllerModelRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.s !== undefined) {
      queryParameters["s"] = requestParameters.s;
    }

    if (requestParameters.filter) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.or) {
      queryParameters["or"] = requestParameters.or;
    }

    if (requestParameters.sort) {
      queryParameters["sort"] = requestParameters.sort;
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    if (requestParameters.offset !== undefined) {
      queryParameters["offset"] = requestParameters.offset;
    }

    if (requestParameters.page !== undefined) {
      queryParameters["page"] = requestParameters.page;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve multiple Models
   */
  getManyBaseModelControllerModel = async (
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number
  ): Promise<Array<object>> => {
    const response = await this.getManyBaseModelControllerModelRaw({
      fields: fields,
      s: s,
      filter: filter,
      or: or,
      sort: sort,
      join: join,
      limit: limit,
      offset: offset,
      page: page,
      cache: cache
    });
    return await response.value();
  };

  useGetManyBaseModelControllerModel(
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number,
    config?: ConfigInterface<Array<object>, Error>
  ) {
    let valid = true;

    const context = this.getManyBaseModelControllerModelContext({
      fields: fields!,
      s: s!,
      filter: filter!,
      or: or!,
      sort: sort!,
      join: join!,
      limit: limit!,
      offset: offset!,
      page: page!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid
        ? () =>
            this.getManyBaseModelControllerModel(
              fields!,
              s!,
              filter!,
              or!,
              sort!,
              join!,
              limit!,
              offset!,
              page!,
              cache!
            )
        : undefined,
      config
    );
  }

  /**
   * Retrieve multiple Tickets
   */
  private async getManyBaseTicketControllerTicketRaw(
    requestParameters: GetManyBaseTicketControllerTicketRequest
  ): Promise<runtime.ApiResponse<Array<Ticket>>> {
    this.getManyBaseTicketControllerTicketValidation(requestParameters);
    const context = this.getManyBaseTicketControllerTicketContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(TicketFromJSON));
  }

  /**
   * Retrieve multiple Tickets
   */
  private getManyBaseTicketControllerTicketValidation(requestParameters: GetManyBaseTicketControllerTicketRequest) {}

  /**
   * Retrieve multiple Tickets
   */
  private getManyBaseTicketControllerTicketContext(
    requestParameters: GetManyBaseTicketControllerTicketRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.s !== undefined) {
      queryParameters["s"] = requestParameters.s;
    }

    if (requestParameters.filter) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.or) {
      queryParameters["or"] = requestParameters.or;
    }

    if (requestParameters.sort) {
      queryParameters["sort"] = requestParameters.sort;
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    if (requestParameters.offset !== undefined) {
      queryParameters["offset"] = requestParameters.offset;
    }

    if (requestParameters.page !== undefined) {
      queryParameters["page"] = requestParameters.page;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve multiple Tickets
   */
  getManyBaseTicketControllerTicket = async (
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number
  ): Promise<Array<Ticket>> => {
    const response = await this.getManyBaseTicketControllerTicketRaw({
      fields: fields,
      s: s,
      filter: filter,
      or: or,
      sort: sort,
      join: join,
      limit: limit,
      offset: offset,
      page: page,
      cache: cache
    });
    return await response.value();
  };

  useGetManyBaseTicketControllerTicket(
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number,
    config?: ConfigInterface<Array<Ticket>, Error>
  ) {
    let valid = true;

    const context = this.getManyBaseTicketControllerTicketContext({
      fields: fields!,
      s: s!,
      filter: filter!,
      or: or!,
      sort: sort!,
      join: join!,
      limit: limit!,
      offset: offset!,
      page: page!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid
        ? () =>
            this.getManyBaseTicketControllerTicket(
              fields!,
              s!,
              filter!,
              or!,
              sort!,
              join!,
              limit!,
              offset!,
              page!,
              cache!
            )
        : undefined,
      config
    );
  }

  /**
   * Retrieve multiple Transfers
   */
  private async getManyBaseTransferControllerTransferRaw(
    requestParameters: GetManyBaseTransferControllerTransferRequest
  ): Promise<runtime.ApiResponse<Array<Transfer>>> {
    this.getManyBaseTransferControllerTransferValidation(requestParameters);
    const context = this.getManyBaseTransferControllerTransferContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(TransferFromJSON));
  }

  /**
   * Retrieve multiple Transfers
   */
  private getManyBaseTransferControllerTransferValidation(
    requestParameters: GetManyBaseTransferControllerTransferRequest
  ) {}

  /**
   * Retrieve multiple Transfers
   */
  private getManyBaseTransferControllerTransferContext(
    requestParameters: GetManyBaseTransferControllerTransferRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.s !== undefined) {
      queryParameters["s"] = requestParameters.s;
    }

    if (requestParameters.filter) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.or) {
      queryParameters["or"] = requestParameters.or;
    }

    if (requestParameters.sort) {
      queryParameters["sort"] = requestParameters.sort;
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    if (requestParameters.offset !== undefined) {
      queryParameters["offset"] = requestParameters.offset;
    }

    if (requestParameters.page !== undefined) {
      queryParameters["page"] = requestParameters.page;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/transfer`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve multiple Transfers
   */
  getManyBaseTransferControllerTransfer = async (
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number
  ): Promise<Array<Transfer>> => {
    const response = await this.getManyBaseTransferControllerTransferRaw({
      fields: fields,
      s: s,
      filter: filter,
      or: or,
      sort: sort,
      join: join,
      limit: limit,
      offset: offset,
      page: page,
      cache: cache
    });
    return await response.value();
  };

  useGetManyBaseTransferControllerTransfer(
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number,
    config?: ConfigInterface<Array<Transfer>, Error>
  ) {
    let valid = true;

    const context = this.getManyBaseTransferControllerTransferContext({
      fields: fields!,
      s: s!,
      filter: filter!,
      or: or!,
      sort: sort!,
      join: join!,
      limit: limit!,
      offset: offset!,
      page: page!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid
        ? () =>
            this.getManyBaseTransferControllerTransfer(
              fields!,
              s!,
              filter!,
              or!,
              sort!,
              join!,
              limit!,
              offset!,
              page!,
              cache!
            )
        : undefined,
      config
    );
  }

  /**
   * Retrieve multiple Warehouses
   */
  private async getManyBaseWarehouseControllerWarehouseRaw(
    requestParameters: GetManyBaseWarehouseControllerWarehouseRequest
  ): Promise<runtime.ApiResponse<Array<Warehouse>>> {
    this.getManyBaseWarehouseControllerWarehouseValidation(requestParameters);
    const context = this.getManyBaseWarehouseControllerWarehouseContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(WarehouseFromJSON));
  }

  /**
   * Retrieve multiple Warehouses
   */
  private getManyBaseWarehouseControllerWarehouseValidation(
    requestParameters: GetManyBaseWarehouseControllerWarehouseRequest
  ) {}

  /**
   * Retrieve multiple Warehouses
   */
  private getManyBaseWarehouseControllerWarehouseContext(
    requestParameters: GetManyBaseWarehouseControllerWarehouseRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.s !== undefined) {
      queryParameters["s"] = requestParameters.s;
    }

    if (requestParameters.filter) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.or) {
      queryParameters["or"] = requestParameters.or;
    }

    if (requestParameters.sort) {
      queryParameters["sort"] = requestParameters.sort;
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    if (requestParameters.offset !== undefined) {
      queryParameters["offset"] = requestParameters.offset;
    }

    if (requestParameters.page !== undefined) {
      queryParameters["page"] = requestParameters.page;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/warehouse`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve multiple Warehouses
   */
  getManyBaseWarehouseControllerWarehouse = async (
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number
  ): Promise<Array<Warehouse>> => {
    const response = await this.getManyBaseWarehouseControllerWarehouseRaw({
      fields: fields,
      s: s,
      filter: filter,
      or: or,
      sort: sort,
      join: join,
      limit: limit,
      offset: offset,
      page: page,
      cache: cache
    });
    return await response.value();
  };

  useGetManyBaseWarehouseControllerWarehouse(
    fields?: Array<string>,
    s?: string,
    filter?: Array<string>,
    or?: Array<string>,
    sort?: Array<string>,
    join?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    cache?: number,
    config?: ConfigInterface<Array<Warehouse>, Error>
  ) {
    let valid = true;

    const context = this.getManyBaseWarehouseControllerWarehouseContext({
      fields: fields!,
      s: s!,
      filter: filter!,
      or: or!,
      sort: sort!,
      join: join!,
      limit: limit!,
      offset: offset!,
      page: page!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid
        ? () =>
            this.getManyBaseWarehouseControllerWarehouse(
              fields!,
              s!,
              filter!,
              or!,
              sort!,
              join!,
              limit!,
              offset!,
              page!,
              cache!
            )
        : undefined,
      config
    );
  }

  /**
   * Retrieve a single Asset
   */
  private async getOneBaseAssetControllerAssetRaw(
    requestParameters: GetOneBaseAssetControllerAssetRequest
  ): Promise<runtime.ApiResponse<object>> {
    this.getOneBaseAssetControllerAssetValidation(requestParameters);
    const context = this.getOneBaseAssetControllerAssetContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve a single Asset
   */
  private getOneBaseAssetControllerAssetValidation(requestParameters: GetOneBaseAssetControllerAssetRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getOneBaseAssetControllerAsset."
      );
    }
  }

  /**
   * Retrieve a single Asset
   */
  private getOneBaseAssetControllerAssetContext(
    requestParameters: GetOneBaseAssetControllerAssetRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve a single Asset
   */
  getOneBaseAssetControllerAsset = async (
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number
  ): Promise<object> => {
    const response = await this.getOneBaseAssetControllerAssetRaw({ id: id, fields: fields, join: join, cache: cache });
    return await response.value();
  };

  useGetOneBaseAssetControllerAsset(
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number,
    config?: ConfigInterface<object, Error>
  ) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.getOneBaseAssetControllerAssetContext({
      id: id!,
      fields: fields!,
      join: join!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.getOneBaseAssetControllerAsset(id!, fields!, join!, cache!) : undefined,
      config
    );
  }

  /**
   * Retrieve a single Manufacturer
   */
  private async getOneBaseManufacturerControllerManufacturerRaw(
    requestParameters: GetOneBaseManufacturerControllerManufacturerRequest
  ): Promise<runtime.ApiResponse<Manufacturer>> {
    this.getOneBaseManufacturerControllerManufacturerValidation(requestParameters);
    const context = this.getOneBaseManufacturerControllerManufacturerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ManufacturerFromJSON(jsonValue));
  }

  /**
   * Retrieve a single Manufacturer
   */
  private getOneBaseManufacturerControllerManufacturerValidation(
    requestParameters: GetOneBaseManufacturerControllerManufacturerRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getOneBaseManufacturerControllerManufacturer."
      );
    }
  }

  /**
   * Retrieve a single Manufacturer
   */
  private getOneBaseManufacturerControllerManufacturerContext(
    requestParameters: GetOneBaseManufacturerControllerManufacturerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/manufacturer/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve a single Manufacturer
   */
  getOneBaseManufacturerControllerManufacturer = async (
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number
  ): Promise<Manufacturer> => {
    const response = await this.getOneBaseManufacturerControllerManufacturerRaw({
      id: id,
      fields: fields,
      join: join,
      cache: cache
    });
    return await response.value();
  };

  useGetOneBaseManufacturerControllerManufacturer(
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number,
    config?: ConfigInterface<Manufacturer, Error>
  ) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.getOneBaseManufacturerControllerManufacturerContext({
      id: id!,
      fields: fields!,
      join: join!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.getOneBaseManufacturerControllerManufacturer(id!, fields!, join!, cache!) : undefined,
      config
    );
  }

  /**
   * Retrieve a single Model
   */
  private async getOneBaseModelControllerModelRaw(
    requestParameters: GetOneBaseModelControllerModelRequest
  ): Promise<runtime.ApiResponse<object>> {
    this.getOneBaseModelControllerModelValidation(requestParameters);
    const context = this.getOneBaseModelControllerModelContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve a single Model
   */
  private getOneBaseModelControllerModelValidation(requestParameters: GetOneBaseModelControllerModelRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getOneBaseModelControllerModel."
      );
    }
  }

  /**
   * Retrieve a single Model
   */
  private getOneBaseModelControllerModelContext(
    requestParameters: GetOneBaseModelControllerModelRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve a single Model
   */
  getOneBaseModelControllerModel = async (
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number
  ): Promise<object> => {
    const response = await this.getOneBaseModelControllerModelRaw({ id: id, fields: fields, join: join, cache: cache });
    return await response.value();
  };

  useGetOneBaseModelControllerModel(
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number,
    config?: ConfigInterface<object, Error>
  ) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.getOneBaseModelControllerModelContext({
      id: id!,
      fields: fields!,
      join: join!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.getOneBaseModelControllerModel(id!, fields!, join!, cache!) : undefined,
      config
    );
  }

  /**
   * Retrieve a single Ticket
   */
  private async getOneBaseTicketControllerTicketRaw(
    requestParameters: GetOneBaseTicketControllerTicketRequest
  ): Promise<runtime.ApiResponse<Ticket>> {
    this.getOneBaseTicketControllerTicketValidation(requestParameters);
    const context = this.getOneBaseTicketControllerTicketContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TicketFromJSON(jsonValue));
  }

  /**
   * Retrieve a single Ticket
   */
  private getOneBaseTicketControllerTicketValidation(requestParameters: GetOneBaseTicketControllerTicketRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getOneBaseTicketControllerTicket."
      );
    }
  }

  /**
   * Retrieve a single Ticket
   */
  private getOneBaseTicketControllerTicketContext(
    requestParameters: GetOneBaseTicketControllerTicketRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve a single Ticket
   */
  getOneBaseTicketControllerTicket = async (
    id: number,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number
  ): Promise<Ticket> => {
    const response = await this.getOneBaseTicketControllerTicketRaw({
      id: id,
      fields: fields,
      join: join,
      cache: cache
    });
    return await response.value();
  };

  useGetOneBaseTicketControllerTicket(
    id: number,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number,
    config?: ConfigInterface<Ticket, Error>
  ) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.getOneBaseTicketControllerTicketContext({
      id: id!,
      fields: fields!,
      join: join!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.getOneBaseTicketControllerTicket(id!, fields!, join!, cache!) : undefined,
      config
    );
  }

  /**
   * Retrieve a single Transfer
   */
  private async getOneBaseTransferControllerTransferRaw(
    requestParameters: GetOneBaseTransferControllerTransferRequest
  ): Promise<runtime.ApiResponse<Transfer>> {
    this.getOneBaseTransferControllerTransferValidation(requestParameters);
    const context = this.getOneBaseTransferControllerTransferContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TransferFromJSON(jsonValue));
  }

  /**
   * Retrieve a single Transfer
   */
  private getOneBaseTransferControllerTransferValidation(
    requestParameters: GetOneBaseTransferControllerTransferRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getOneBaseTransferControllerTransfer."
      );
    }
  }

  /**
   * Retrieve a single Transfer
   */
  private getOneBaseTransferControllerTransferContext(
    requestParameters: GetOneBaseTransferControllerTransferRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/transfer/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve a single Transfer
   */
  getOneBaseTransferControllerTransfer = async (
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number
  ): Promise<Transfer> => {
    const response = await this.getOneBaseTransferControllerTransferRaw({
      id: id,
      fields: fields,
      join: join,
      cache: cache
    });
    return await response.value();
  };

  useGetOneBaseTransferControllerTransfer(
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number,
    config?: ConfigInterface<Transfer, Error>
  ) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.getOneBaseTransferControllerTransferContext({
      id: id!,
      fields: fields!,
      join: join!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.getOneBaseTransferControllerTransfer(id!, fields!, join!, cache!) : undefined,
      config
    );
  }

  /**
   * Retrieve a single Warehouse
   */
  private async getOneBaseWarehouseControllerWarehouseRaw(
    requestParameters: GetOneBaseWarehouseControllerWarehouseRequest
  ): Promise<runtime.ApiResponse<Warehouse>> {
    this.getOneBaseWarehouseControllerWarehouseValidation(requestParameters);
    const context = this.getOneBaseWarehouseControllerWarehouseContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => WarehouseFromJSON(jsonValue));
  }

  /**
   * Retrieve a single Warehouse
   */
  private getOneBaseWarehouseControllerWarehouseValidation(
    requestParameters: GetOneBaseWarehouseControllerWarehouseRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getOneBaseWarehouseControllerWarehouse."
      );
    }
  }

  /**
   * Retrieve a single Warehouse
   */
  private getOneBaseWarehouseControllerWarehouseContext(
    requestParameters: GetOneBaseWarehouseControllerWarehouseRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.fields) {
      queryParameters["fields"] = requestParameters.fields.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    if (requestParameters.join) {
      queryParameters["join"] = requestParameters.join;
    }

    if (requestParameters.cache !== undefined) {
      queryParameters["cache"] = requestParameters.cache;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/warehouse/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   * Retrieve a single Warehouse
   */
  getOneBaseWarehouseControllerWarehouse = async (
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number
  ): Promise<Warehouse> => {
    const response = await this.getOneBaseWarehouseControllerWarehouseRaw({
      id: id,
      fields: fields,
      join: join,
      cache: cache
    });
    return await response.value();
  };

  useGetOneBaseWarehouseControllerWarehouse(
    id: string,
    fields?: Array<string>,
    join?: Array<string>,
    cache?: number,
    config?: ConfigInterface<Warehouse, Error>
  ) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.getOneBaseWarehouseControllerWarehouseContext({
      id: id!,
      fields: fields!,
      join: join!,
      cache: cache!
    });
    const { headers, ...swrKey } = context;
    return useSWR(
      JSON.stringify(swrKey),
      valid ? () => this.getOneBaseWarehouseControllerWarehouse(id!, fields!, join!, cache!) : undefined,
      config
    );
  }

  /**
   */
  private async interfaceRolesRaw(): Promise<runtime.ApiResponse<Array<InterfaceRole>>> {
    this.interfaceRolesValidation();
    const context = this.interfaceRolesContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(InterfaceRoleFromJSON));
  }

  /**
   */
  private interfaceRolesValidation() {}

  /**
   */
  private interfaceRolesContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/api/admin/dcim/interface-role`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  interfaceRoles = async (): Promise<Array<InterfaceRole>> => {
    const response = await this.interfaceRolesRaw();
    return await response.value();
  };

  useInterfaceRoles(config?: ConfigInterface<Array<InterfaceRole>, Error>) {
    let valid = true;

    const context = this.interfaceRolesContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.interfaceRoles() : undefined, config);
  }

  /**
   */
  private async locationRaw(requestParameters: LocationRequest): Promise<runtime.ApiResponse<DataCenter>> {
    this.locationValidation(requestParameters);
    const context = this.locationContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => DataCenterFromJSON(jsonValue));
  }

  /**
   */
  private locationValidation(requestParameters: LocationRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling location."
      );
    }
  }

  /**
   */
  private locationContext(requestParameters: LocationRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/api/admin/dcim/data-center/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  location = async (id: number): Promise<DataCenter> => {
    const response = await this.locationRaw({ id: id });
    return await response.value();
  };

  useLocation(id: number, config?: ConfigInterface<DataCenter, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.locationContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.location(id!) : undefined, config);
  }

  /**
   */
  private async locationsRaw(): Promise<runtime.ApiResponse<Array<DataCenter>>> {
    this.locationsValidation();
    const context = this.locationsContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(DataCenterFromJSON));
  }

  /**
   */
  private locationsValidation() {}

  /**
   */
  private locationsContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/api/admin/dcim/data-center`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  locations = async (): Promise<Array<DataCenter>> => {
    const response = await this.locationsRaw();
    return await response.value();
  };

  useLocations(config?: ConfigInterface<Array<DataCenter>, Error>) {
    let valid = true;

    const context = this.locationsContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.locations() : undefined, config);
  }

  /**
   */
  private async operatingSystemsRaw(): Promise<runtime.ApiResponse<Array<OperatingSystem>>> {
    this.operatingSystemsValidation();
    const context = this.operatingSystemsContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(OperatingSystemFromJSON));
  }

  /**
   */
  private operatingSystemsValidation() {}

  /**
   */
  private operatingSystemsContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/operating-system`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  operatingSystems = async (): Promise<Array<OperatingSystem>> => {
    const response = await this.operatingSystemsRaw();
    return await response.value();
  };

  useOperatingSystems(config?: ConfigInterface<Array<OperatingSystem>, Error>) {
    let valid = true;

    const context = this.operatingSystemsContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.operatingSystems() : undefined, config);
  }

  /**
   */
  private async prefixesRaw(requestParameters: PrefixesRequest): Promise<runtime.ApiResponse<Array<Prefix>>> {
    this.prefixesValidation(requestParameters);
    const context = this.prefixesContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(PrefixFromJSON));
  }

  /**
   */
  private prefixesValidation(requestParameters: PrefixesRequest) {
    if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
      throw new runtime.RequiredError(
        "locationId",
        "Required parameter requestParameters.locationId was null or undefined when calling prefixes."
      );
    }
  }

  /**
   */
  private prefixesContext(requestParameters: PrefixesRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.locationId !== undefined) {
      queryParameters["locationId"] = requestParameters.locationId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/address`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  prefixes = async (locationId: number): Promise<Array<Prefix>> => {
    const response = await this.prefixesRaw({ locationId: locationId });
    return await response.value();
  };

  usePrefixes(locationId: number, config?: ConfigInterface<Array<Prefix>, Error>) {
    let valid = true;

    if (locationId === null || locationId === undefined || Number.isNaN(locationId)) {
      valid = false;
    }

    const context = this.prefixesContext({ locationId: locationId! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.prefixes(locationId!) : undefined, config);
  }

  /**
   */
  private async rackRaw(requestParameters: RackRequest): Promise<runtime.ApiResponse<Rack>> {
    this.rackValidation(requestParameters);
    const context = this.rackContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => RackFromJSON(jsonValue));
  }

  /**
   */
  private rackValidation(requestParameters: RackRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling rack."
      );
    }
  }

  /**
   */
  private rackContext(requestParameters: RackRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/rack/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  rack = async (id: number): Promise<Rack> => {
    const response = await this.rackRaw({ id: id });
    return await response.value();
  };

  useRack(id: number, config?: ConfigInterface<Rack, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.rackContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.rack(id!) : undefined, config);
  }

  /**
   */
  private async rackElevationRaw(
    requestParameters: RackElevationRequest
  ): Promise<runtime.ApiResponse<Array<RackUnit>>> {
    this.rackElevationValidation(requestParameters);
    const context = this.rackElevationContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(RackUnitFromJSON));
  }

  /**
   */
  private rackElevationValidation(requestParameters: RackElevationRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling rackElevation."
      );
    }
  }

  /**
   */
  private rackElevationContext(requestParameters: RackElevationRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/rack/{id}/elevation`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  rackElevation = async (id: number): Promise<Array<RackUnit>> => {
    const response = await this.rackElevationRaw({ id: id });
    return await response.value();
  };

  useRackElevation(id: number, config?: ConfigInterface<Array<RackUnit>, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.rackElevationContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.rackElevation(id!) : undefined, config);
  }

  /**
   */
  private async racksRaw(requestParameters: RacksRequest): Promise<runtime.ApiResponse<Array<Rack>>> {
    this.racksValidation(requestParameters);
    const context = this.racksContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(RackFromJSON));
  }

  /**
   */
  private racksValidation(requestParameters: RacksRequest) {}

  /**
   */
  private racksContext(requestParameters: RacksRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.siteId !== undefined) {
      queryParameters["site_id"] = requestParameters.siteId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/rack`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  racks = async (siteId?: number): Promise<Array<Rack>> => {
    const response = await this.racksRaw({ siteId: siteId });
    return await response.value();
  };

  useRacks(siteId?: number, config?: ConfigInterface<Array<Rack>, Error>) {
    let valid = true;

    const context = this.racksContext({ siteId: siteId! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.racks(siteId!) : undefined, config);
  }

  /**
   */
  private async reloadServerStatusRaw(
    requestParameters: ReloadServerStatusRequest
  ): Promise<runtime.ApiResponse<object>> {
    this.reloadServerStatusValidation(requestParameters);
    const context = this.reloadServerStatusContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private reloadServerStatusValidation(requestParameters: ReloadServerStatusRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling reloadServerStatus."
      );
    }
  }

  /**
   */
  private reloadServerStatusContext(requestParameters: ReloadServerStatusRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/status/reload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  reloadServerStatus = async (id: number): Promise<object> => {
    const response = await this.reloadServerStatusRaw({ id: id });
    return await response.value();
  };

  /**
   */
  private async resetServerRaw(requestParameters: ResetServerRequest): Promise<runtime.ApiResponse<void>> {
    this.resetServerValidation(requestParameters);
    const context = this.resetServerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private resetServerValidation(requestParameters: ResetServerRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling resetServer."
      );
    }
  }

  /**
   */
  private resetServerContext(requestParameters: ResetServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/reset`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  resetServer = async (id: number): Promise<void> => {
    await this.resetServerRaw({ id: id });
  };

  /**
   */
  private async rolesRaw(): Promise<runtime.ApiResponse<Array<ServerRole>>> {
    this.rolesValidation();
    const context = this.rolesContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(ServerRoleFromJSON));
  }

  /**
   */
  private rolesValidation() {}

  /**
   */
  private rolesContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/api/admin/dcim/server-role`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  roles = async (): Promise<Array<ServerRole>> => {
    const response = await this.rolesRaw();
    return await response.value();
  };

  useRoles(config?: ConfigInterface<Array<ServerRole>, Error>) {
    let valid = true;

    const context = this.rolesContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.roles() : undefined, config);
  }

  /**
   */
  private async serverRaw(requestParameters: ServerRequest): Promise<runtime.ApiResponse<Server>> {
    this.serverValidation(requestParameters);
    const context = this.serverContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ServerFromJSON(jsonValue));
  }

  /**
   */
  private serverValidation(requestParameters: ServerRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling server."
      );
    }
  }

  /**
   */
  private serverContext(requestParameters: ServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  server = async (id: number): Promise<Server> => {
    const response = await this.serverRaw({ id: id });
    return await response.value();
  };

  useServer(id: number, config?: ConfigInterface<Server, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.serverContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.server(id!) : undefined, config);
  }

  /**
   */
  private async serverTestsRaw(
    requestParameters: ServerTestsRequest
  ): Promise<runtime.ApiResponse<Array<ServerTestResultDto>>> {
    this.serverTestsValidation(requestParameters);
    const context = this.serverTestsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(ServerTestResultDtoFromJSON));
  }

  /**
   */
  private serverTestsValidation(requestParameters: ServerTestsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling serverTests."
      );
    }
  }

  /**
   */
  private serverTestsContext(requestParameters: ServerTestsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/test`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  serverTests = async (id: number): Promise<Array<ServerTestResultDto>> => {
    const response = await this.serverTestsRaw({ id: id });
    return await response.value();
  };

  useServerTests(id: number, config?: ConfigInterface<Array<ServerTestResultDto>, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.serverTestsContext({ id: id! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.serverTests(id!) : undefined, config);
  }

  /**
   */
  private async serverUpdateInterfacesRaw(
    requestParameters: ServerUpdateInterfacesRequest
  ): Promise<runtime.ApiResponse<Server>> {
    this.serverUpdateInterfacesValidation(requestParameters);
    const context = this.serverUpdateInterfacesContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ServerFromJSON(jsonValue));
  }

  /**
   */
  private serverUpdateInterfacesValidation(requestParameters: ServerUpdateInterfacesRequest) {
    if (requestParameters.serverId === null || requestParameters.serverId === undefined) {
      throw new runtime.RequiredError(
        "serverId",
        "Required parameter requestParameters.serverId was null or undefined when calling serverUpdateInterfaces."
      );
    }
    if (requestParameters.updateInterfaceDto === null || requestParameters.updateInterfaceDto === undefined) {
      throw new runtime.RequiredError(
        "updateInterfaceDto",
        "Required parameter requestParameters.updateInterfaceDto was null or undefined when calling serverUpdateInterfaces."
      );
    }
  }

  /**
   */
  private serverUpdateInterfacesContext(requestParameters: ServerUpdateInterfacesRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{serverId}/interfaces`.replace(
        `{${"serverId"}}`,
        encodeURIComponent(String(requestParameters.serverId))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.updateInterfaceDto.map(UpdateInterfaceDtoToJSON)
    };
  }

  /**
   */
  serverUpdateInterfaces = async (serverId: number, updateInterfaceDto: Array<UpdateInterfaceDto>): Promise<Server> => {
    const response = await this.serverUpdateInterfacesRaw({
      serverId: serverId,
      updateInterfaceDto: updateInterfaceDto
    });
    return await response.value();
  };

  /**
   */
  private async serversRaw(requestParameters: ServersRequest): Promise<runtime.ApiResponse<Array<Server>>> {
    this.serversValidation(requestParameters);
    const context = this.serversContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(ServerFromJSON));
  }

  /**
   */
  private serversValidation(requestParameters: ServersRequest) {}

  /**
   */
  private serversContext(requestParameters: ServersRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters["type"] = requestParameters.type;
    }

    if (requestParameters.withInterfaces !== undefined) {
      queryParameters["withInterfaces"] = requestParameters.withInterfaces;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  servers = async (type?: ServersTypeEnum, withInterfaces?: boolean): Promise<Array<Server>> => {
    const response = await this.serversRaw({ type: type, withInterfaces: withInterfaces });
    return await response.value();
  };

  useServers(type?: ServersTypeEnum, withInterfaces?: boolean, config?: ConfigInterface<Array<Server>, Error>) {
    let valid = true;

    const context = this.serversContext({ type: type!, withInterfaces: withInterfaces! });
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.servers(type!, withInterfaces!) : undefined, config);
  }

  /**
   */
  private async tagsRaw(): Promise<runtime.ApiResponse<Array<string>>> {
    this.tagsValidation();
    const context = this.tagsContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  private tagsValidation() {}

  /**
   */
  private tagsContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/tags`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  tags = async (): Promise<Array<string>> => {
    const response = await this.tagsRaw();
    return await response.value();
  };

  useTags(config?: ConfigInterface<Array<string>, Error>) {
    let valid = true;

    const context = this.tagsContext();
    const { headers, ...swrKey } = context;
    return useSWR(JSON.stringify(swrKey), valid ? () => this.tags() : undefined, config);
  }

  /**
   */
  private async turnOffServerRaw(requestParameters: TurnOffServerRequest): Promise<runtime.ApiResponse<void>> {
    this.turnOffServerValidation(requestParameters);
    const context = this.turnOffServerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private turnOffServerValidation(requestParameters: TurnOffServerRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling turnOffServer."
      );
    }
  }

  /**
   */
  private turnOffServerContext(requestParameters: TurnOffServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/turnOff`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  turnOffServer = async (id: number): Promise<void> => {
    await this.turnOffServerRaw({ id: id });
  };

  /**
   */
  private async turnOnServerRaw(requestParameters: TurnOnServerRequest): Promise<runtime.ApiResponse<void>> {
    this.turnOnServerValidation(requestParameters);
    const context = this.turnOnServerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  private turnOnServerValidation(requestParameters: TurnOnServerRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling turnOnServer."
      );
    }
  }

  /**
   */
  private turnOnServerContext(requestParameters: TurnOnServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/turnOn`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  turnOnServer = async (id: number): Promise<void> => {
    await this.turnOnServerRaw({ id: id });
  };

  /**
   * Update a single Asset
   */
  private async updateOneBaseAssetControllerAssetRaw(
    requestParameters: UpdateOneBaseAssetControllerAssetRequest
  ): Promise<runtime.ApiResponse<Asset>> {
    this.updateOneBaseAssetControllerAssetValidation(requestParameters);
    const context = this.updateOneBaseAssetControllerAssetContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => AssetFromJSON(jsonValue));
  }

  /**
   * Update a single Asset
   */
  private updateOneBaseAssetControllerAssetValidation(requestParameters: UpdateOneBaseAssetControllerAssetRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseAssetControllerAsset."
      );
    }
    if (requestParameters.assetDto === null || requestParameters.assetDto === undefined) {
      throw new runtime.RequiredError(
        "assetDto",
        "Required parameter requestParameters.assetDto was null or undefined when calling updateOneBaseAssetControllerAsset."
      );
    }
  }

  /**
   * Update a single Asset
   */
  private updateOneBaseAssetControllerAssetContext(
    requestParameters: UpdateOneBaseAssetControllerAssetRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/asset/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: AssetDtoToJSON(requestParameters.assetDto)
    };
  }

  /**
   * Update a single Asset
   */
  updateOneBaseAssetControllerAsset = async (id: string, assetDto: AssetDto): Promise<Asset> => {
    const response = await this.updateOneBaseAssetControllerAssetRaw({ id: id, assetDto: assetDto });
    return await response.value();
  };

  /**
   * Update a single Disk
   */
  private async updateOneBaseDiskControllerDiskRaw(
    requestParameters: UpdateOneBaseDiskControllerDiskRequest
  ): Promise<runtime.ApiResponse<Disk>> {
    this.updateOneBaseDiskControllerDiskValidation(requestParameters);
    const context = this.updateOneBaseDiskControllerDiskContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => DiskFromJSON(jsonValue));
  }

  /**
   * Update a single Disk
   */
  private updateOneBaseDiskControllerDiskValidation(requestParameters: UpdateOneBaseDiskControllerDiskRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseDiskControllerDisk."
      );
    }
    if (requestParameters.diskDto === null || requestParameters.diskDto === undefined) {
      throw new runtime.RequiredError(
        "diskDto",
        "Required parameter requestParameters.diskDto was null or undefined when calling updateOneBaseDiskControllerDisk."
      );
    }
  }

  /**
   * Update a single Disk
   */
  private updateOneBaseDiskControllerDiskContext(
    requestParameters: UpdateOneBaseDiskControllerDiskRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/disk/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: DiskDtoToJSON(requestParameters.diskDto)
    };
  }

  /**
   * Update a single Disk
   */
  updateOneBaseDiskControllerDisk = async (id: string, diskDto: DiskDto): Promise<Disk> => {
    const response = await this.updateOneBaseDiskControllerDiskRaw({ id: id, diskDto: diskDto });
    return await response.value();
  };

  /**
   * Update a single Manufacturer
   */
  private async updateOneBaseManufacturerControllerManufacturerRaw(
    requestParameters: UpdateOneBaseManufacturerControllerManufacturerRequest
  ): Promise<runtime.ApiResponse<Manufacturer>> {
    this.updateOneBaseManufacturerControllerManufacturerValidation(requestParameters);
    const context = this.updateOneBaseManufacturerControllerManufacturerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ManufacturerFromJSON(jsonValue));
  }

  /**
   * Update a single Manufacturer
   */
  private updateOneBaseManufacturerControllerManufacturerValidation(
    requestParameters: UpdateOneBaseManufacturerControllerManufacturerRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseManufacturerControllerManufacturer."
      );
    }
    if (requestParameters.manufacturerDto === null || requestParameters.manufacturerDto === undefined) {
      throw new runtime.RequiredError(
        "manufacturerDto",
        "Required parameter requestParameters.manufacturerDto was null or undefined when calling updateOneBaseManufacturerControllerManufacturer."
      );
    }
  }

  /**
   * Update a single Manufacturer
   */
  private updateOneBaseManufacturerControllerManufacturerContext(
    requestParameters: UpdateOneBaseManufacturerControllerManufacturerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/manufacturer/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: ManufacturerDtoToJSON(requestParameters.manufacturerDto)
    };
  }

  /**
   * Update a single Manufacturer
   */
  updateOneBaseManufacturerControllerManufacturer = async (
    id: string,
    manufacturerDto: ManufacturerDto
  ): Promise<Manufacturer> => {
    const response = await this.updateOneBaseManufacturerControllerManufacturerRaw({
      id: id,
      manufacturerDto: manufacturerDto
    });
    return await response.value();
  };

  /**
   * Update a single NetworkInterface
   */
  private async updateOneBaseNetworkInterfaceControllerNetworkInterfaceRaw(
    requestParameters: UpdateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ): Promise<runtime.ApiResponse<NetworkInterface>> {
    this.updateOneBaseNetworkInterfaceControllerNetworkInterfaceValidation(requestParameters);
    const context = this.updateOneBaseNetworkInterfaceControllerNetworkInterfaceContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => NetworkInterfaceFromJSON(jsonValue));
  }

  /**
   * Update a single NetworkInterface
   */
  private updateOneBaseNetworkInterfaceControllerNetworkInterfaceValidation(
    requestParameters: UpdateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseNetworkInterfaceControllerNetworkInterface."
      );
    }
    if (requestParameters.networkInterfaceDto === null || requestParameters.networkInterfaceDto === undefined) {
      throw new runtime.RequiredError(
        "networkInterfaceDto",
        "Required parameter requestParameters.networkInterfaceDto was null or undefined when calling updateOneBaseNetworkInterfaceControllerNetworkInterface."
      );
    }
  }

  /**
   * Update a single NetworkInterface
   */
  private updateOneBaseNetworkInterfaceControllerNetworkInterfaceContext(
    requestParameters: UpdateOneBaseNetworkInterfaceControllerNetworkInterfaceRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/network-interface/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: NetworkInterfaceDtoToJSON(requestParameters.networkInterfaceDto)
    };
  }

  /**
   * Update a single NetworkInterface
   */
  updateOneBaseNetworkInterfaceControllerNetworkInterface = async (
    id: string,
    networkInterfaceDto: NetworkInterfaceDto
  ): Promise<NetworkInterface> => {
    const response = await this.updateOneBaseNetworkInterfaceControllerNetworkInterfaceRaw({
      id: id,
      networkInterfaceDto: networkInterfaceDto
    });
    return await response.value();
  };

  /**
   * Update a single Platform
   */
  private async updateOneBasePlatformControllerPlatformRaw(
    requestParameters: UpdateOneBasePlatformControllerPlatformRequest
  ): Promise<runtime.ApiResponse<Platform>> {
    this.updateOneBasePlatformControllerPlatformValidation(requestParameters);
    const context = this.updateOneBasePlatformControllerPlatformContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PlatformFromJSON(jsonValue));
  }

  /**
   * Update a single Platform
   */
  private updateOneBasePlatformControllerPlatformValidation(
    requestParameters: UpdateOneBasePlatformControllerPlatformRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBasePlatformControllerPlatform."
      );
    }
    if (requestParameters.platformDto === null || requestParameters.platformDto === undefined) {
      throw new runtime.RequiredError(
        "platformDto",
        "Required parameter requestParameters.platformDto was null or undefined when calling updateOneBasePlatformControllerPlatform."
      );
    }
  }

  /**
   * Update a single Platform
   */
  private updateOneBasePlatformControllerPlatformContext(
    requestParameters: UpdateOneBasePlatformControllerPlatformRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/platform/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PlatformDtoToJSON(requestParameters.platformDto)
    };
  }

  /**
   * Update a single Platform
   */
  updateOneBasePlatformControllerPlatform = async (id: string, platformDto: PlatformDto): Promise<Platform> => {
    const response = await this.updateOneBasePlatformControllerPlatformRaw({ id: id, platformDto: platformDto });
    return await response.value();
  };

  /**
   * Update a single PowerUnit
   */
  private async updateOneBasePowerUnitControllerPowerUnitRaw(
    requestParameters: UpdateOneBasePowerUnitControllerPowerUnitRequest
  ): Promise<runtime.ApiResponse<PowerUnit>> {
    this.updateOneBasePowerUnitControllerPowerUnitValidation(requestParameters);
    const context = this.updateOneBasePowerUnitControllerPowerUnitContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PowerUnitFromJSON(jsonValue));
  }

  /**
   * Update a single PowerUnit
   */
  private updateOneBasePowerUnitControllerPowerUnitValidation(
    requestParameters: UpdateOneBasePowerUnitControllerPowerUnitRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBasePowerUnitControllerPowerUnit."
      );
    }
    if (requestParameters.powerUnitDto === null || requestParameters.powerUnitDto === undefined) {
      throw new runtime.RequiredError(
        "powerUnitDto",
        "Required parameter requestParameters.powerUnitDto was null or undefined when calling updateOneBasePowerUnitControllerPowerUnit."
      );
    }
  }

  /**
   * Update a single PowerUnit
   */
  private updateOneBasePowerUnitControllerPowerUnitContext(
    requestParameters: UpdateOneBasePowerUnitControllerPowerUnitRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/power-unit/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PowerUnitDtoToJSON(requestParameters.powerUnitDto)
    };
  }

  /**
   * Update a single PowerUnit
   */
  updateOneBasePowerUnitControllerPowerUnit = async (id: string, powerUnitDto: PowerUnitDto): Promise<PowerUnit> => {
    const response = await this.updateOneBasePowerUnitControllerPowerUnitRaw({ id: id, powerUnitDto: powerUnitDto });
    return await response.value();
  };

  /**
   * Update a single Processor
   */
  private async updateOneBaseProcessorControllerProcessorRaw(
    requestParameters: UpdateOneBaseProcessorControllerProcessorRequest
  ): Promise<runtime.ApiResponse<Processor>> {
    this.updateOneBaseProcessorControllerProcessorValidation(requestParameters);
    const context = this.updateOneBaseProcessorControllerProcessorContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ProcessorFromJSON(jsonValue));
  }

  /**
   * Update a single Processor
   */
  private updateOneBaseProcessorControllerProcessorValidation(
    requestParameters: UpdateOneBaseProcessorControllerProcessorRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseProcessorControllerProcessor."
      );
    }
    if (requestParameters.processorDto === null || requestParameters.processorDto === undefined) {
      throw new runtime.RequiredError(
        "processorDto",
        "Required parameter requestParameters.processorDto was null or undefined when calling updateOneBaseProcessorControllerProcessor."
      );
    }
  }

  /**
   * Update a single Processor
   */
  private updateOneBaseProcessorControllerProcessorContext(
    requestParameters: UpdateOneBaseProcessorControllerProcessorRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/processor/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: ProcessorDtoToJSON(requestParameters.processorDto)
    };
  }

  /**
   * Update a single Processor
   */
  updateOneBaseProcessorControllerProcessor = async (id: string, processorDto: ProcessorDto): Promise<Processor> => {
    const response = await this.updateOneBaseProcessorControllerProcessorRaw({ id: id, processorDto: processorDto });
    return await response.value();
  };

  /**
   * Update a single RAIDController
   */
  private async updateOneBaseRAIDControllerControllerRAIDControllerRaw(
    requestParameters: UpdateOneBaseRAIDControllerControllerRAIDControllerRequest
  ): Promise<runtime.ApiResponse<RAIDController>> {
    this.updateOneBaseRAIDControllerControllerRAIDControllerValidation(requestParameters);
    const context = this.updateOneBaseRAIDControllerControllerRAIDControllerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => RAIDControllerFromJSON(jsonValue));
  }

  /**
   * Update a single RAIDController
   */
  private updateOneBaseRAIDControllerControllerRAIDControllerValidation(
    requestParameters: UpdateOneBaseRAIDControllerControllerRAIDControllerRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseRAIDControllerControllerRAIDController."
      );
    }
    if (requestParameters.rAIDControllerDto === null || requestParameters.rAIDControllerDto === undefined) {
      throw new runtime.RequiredError(
        "rAIDControllerDto",
        "Required parameter requestParameters.rAIDControllerDto was null or undefined when calling updateOneBaseRAIDControllerControllerRAIDController."
      );
    }
  }

  /**
   * Update a single RAIDController
   */
  private updateOneBaseRAIDControllerControllerRAIDControllerContext(
    requestParameters: UpdateOneBaseRAIDControllerControllerRAIDControllerRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/raid-controller/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: RAIDControllerDtoToJSON(requestParameters.rAIDControllerDto)
    };
  }

  /**
   * Update a single RAIDController
   */
  updateOneBaseRAIDControllerControllerRAIDController = async (
    id: string,
    rAIDControllerDto: RAIDControllerDto
  ): Promise<RAIDController> => {
    const response = await this.updateOneBaseRAIDControllerControllerRAIDControllerRaw({
      id: id,
      rAIDControllerDto: rAIDControllerDto
    });
    return await response.value();
  };

  /**
   * Update a single RAM
   */
  private async updateOneBaseRAMControllerRAMRaw(
    requestParameters: UpdateOneBaseRAMControllerRAMRequest
  ): Promise<runtime.ApiResponse<RAM>> {
    this.updateOneBaseRAMControllerRAMValidation(requestParameters);
    const context = this.updateOneBaseRAMControllerRAMContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => RAMFromJSON(jsonValue));
  }

  /**
   * Update a single RAM
   */
  private updateOneBaseRAMControllerRAMValidation(requestParameters: UpdateOneBaseRAMControllerRAMRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseRAMControllerRAM."
      );
    }
    if (requestParameters.rAMDto === null || requestParameters.rAMDto === undefined) {
      throw new runtime.RequiredError(
        "rAMDto",
        "Required parameter requestParameters.rAMDto was null or undefined when calling updateOneBaseRAMControllerRAM."
      );
    }
  }

  /**
   * Update a single RAM
   */
  private updateOneBaseRAMControllerRAMContext(
    requestParameters: UpdateOneBaseRAMControllerRAMRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/ram/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: RAMDtoToJSON(requestParameters.rAMDto)
    };
  }

  /**
   * Update a single RAM
   */
  updateOneBaseRAMControllerRAM = async (id: string, rAMDto: RAMDto): Promise<RAM> => {
    const response = await this.updateOneBaseRAMControllerRAMRaw({ id: id, rAMDto: rAMDto });
    return await response.value();
  };

  /**
   * Update a single Switch
   */
  private async updateOneBaseSwitchControllerSwitchRaw(
    requestParameters: UpdateOneBaseSwitchControllerSwitchRequest
  ): Promise<runtime.ApiResponse<Switch>> {
    this.updateOneBaseSwitchControllerSwitchValidation(requestParameters);
    const context = this.updateOneBaseSwitchControllerSwitchContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => SwitchFromJSON(jsonValue));
  }

  /**
   * Update a single Switch
   */
  private updateOneBaseSwitchControllerSwitchValidation(requestParameters: UpdateOneBaseSwitchControllerSwitchRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseSwitchControllerSwitch."
      );
    }
    if (requestParameters.switchDto === null || requestParameters.switchDto === undefined) {
      throw new runtime.RequiredError(
        "switchDto",
        "Required parameter requestParameters.switchDto was null or undefined when calling updateOneBaseSwitchControllerSwitch."
      );
    }
  }

  /**
   * Update a single Switch
   */
  private updateOneBaseSwitchControllerSwitchContext(
    requestParameters: UpdateOneBaseSwitchControllerSwitchRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/model/switch/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: SwitchDtoToJSON(requestParameters.switchDto)
    };
  }

  /**
   * Update a single Switch
   */
  updateOneBaseSwitchControllerSwitch = async (id: string, switchDto: SwitchDto): Promise<Switch> => {
    const response = await this.updateOneBaseSwitchControllerSwitchRaw({ id: id, switchDto: switchDto });
    return await response.value();
  };

  /**
   * Update a single Ticket
   */
  private async updateOneBaseTicketControllerTicketRaw(
    requestParameters: UpdateOneBaseTicketControllerTicketRequest
  ): Promise<runtime.ApiResponse<Ticket>> {
    this.updateOneBaseTicketControllerTicketValidation(requestParameters);
    const context = this.updateOneBaseTicketControllerTicketContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TicketFromJSON(jsonValue));
  }

  /**
   * Update a single Ticket
   */
  private updateOneBaseTicketControllerTicketValidation(requestParameters: UpdateOneBaseTicketControllerTicketRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseTicketControllerTicket."
      );
    }
    if (requestParameters.ticketDto === null || requestParameters.ticketDto === undefined) {
      throw new runtime.RequiredError(
        "ticketDto",
        "Required parameter requestParameters.ticketDto was null or undefined when calling updateOneBaseTicketControllerTicket."
      );
    }
  }

  /**
   * Update a single Ticket
   */
  private updateOneBaseTicketControllerTicketContext(
    requestParameters: UpdateOneBaseTicketControllerTicketRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/ticket/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: TicketDtoToJSON(requestParameters.ticketDto)
    };
  }

  /**
   * Update a single Ticket
   */
  updateOneBaseTicketControllerTicket = async (id: number, ticketDto: TicketDto): Promise<Ticket> => {
    const response = await this.updateOneBaseTicketControllerTicketRaw({ id: id, ticketDto: ticketDto });
    return await response.value();
  };

  /**
   * Update a single Transfer
   */
  private async updateOneBaseTransferControllerTransferRaw(
    requestParameters: UpdateOneBaseTransferControllerTransferRequest
  ): Promise<runtime.ApiResponse<Transfer>> {
    this.updateOneBaseTransferControllerTransferValidation(requestParameters);
    const context = this.updateOneBaseTransferControllerTransferContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => TransferFromJSON(jsonValue));
  }

  /**
   * Update a single Transfer
   */
  private updateOneBaseTransferControllerTransferValidation(
    requestParameters: UpdateOneBaseTransferControllerTransferRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseTransferControllerTransfer."
      );
    }
    if (requestParameters.transferDto === null || requestParameters.transferDto === undefined) {
      throw new runtime.RequiredError(
        "transferDto",
        "Required parameter requestParameters.transferDto was null or undefined when calling updateOneBaseTransferControllerTransfer."
      );
    }
  }

  /**
   * Update a single Transfer
   */
  private updateOneBaseTransferControllerTransferContext(
    requestParameters: UpdateOneBaseTransferControllerTransferRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/transfer/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: TransferDtoToJSON(requestParameters.transferDto)
    };
  }

  /**
   * Update a single Transfer
   */
  updateOneBaseTransferControllerTransfer = async (id: string, transferDto: TransferDto): Promise<Transfer> => {
    const response = await this.updateOneBaseTransferControllerTransferRaw({ id: id, transferDto: transferDto });
    return await response.value();
  };

  /**
   * Update a single Warehouse
   */
  private async updateOneBaseWarehouseControllerWarehouseRaw(
    requestParameters: UpdateOneBaseWarehouseControllerWarehouseRequest
  ): Promise<runtime.ApiResponse<Warehouse>> {
    this.updateOneBaseWarehouseControllerWarehouseValidation(requestParameters);
    const context = this.updateOneBaseWarehouseControllerWarehouseContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => WarehouseFromJSON(jsonValue));
  }

  /**
   * Update a single Warehouse
   */
  private updateOneBaseWarehouseControllerWarehouseValidation(
    requestParameters: UpdateOneBaseWarehouseControllerWarehouseRequest
  ) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateOneBaseWarehouseControllerWarehouse."
      );
    }
    if (requestParameters.warehouseDto === null || requestParameters.warehouseDto === undefined) {
      throw new runtime.RequiredError(
        "warehouseDto",
        "Required parameter requestParameters.warehouseDto was null or undefined when calling updateOneBaseWarehouseControllerWarehouse."
      );
    }
  }

  /**
   * Update a single Warehouse
   */
  private updateOneBaseWarehouseControllerWarehouseContext(
    requestParameters: UpdateOneBaseWarehouseControllerWarehouseRequest
  ): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/warehouse/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: WarehouseDtoToJSON(requestParameters.warehouseDto)
    };
  }

  /**
   * Update a single Warehouse
   */
  updateOneBaseWarehouseControllerWarehouse = async (id: string, warehouseDto: WarehouseDto): Promise<Warehouse> => {
    const response = await this.updateOneBaseWarehouseControllerWarehouseRaw({ id: id, warehouseDto: warehouseDto });
    return await response.value();
  };

  /**
   */
  private async updateServerRaw(requestParameters: UpdateServerRequest): Promise<runtime.ApiResponse<Server>> {
    this.updateServerValidation(requestParameters);
    const context = this.updateServerContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ServerFromJSON(jsonValue));
  }

  /**
   */
  private updateServerValidation(requestParameters: UpdateServerRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateServer."
      );
    }
    if (requestParameters.createUpdateServerDto === null || requestParameters.createUpdateServerDto === undefined) {
      throw new runtime.RequiredError(
        "createUpdateServerDto",
        "Required parameter requestParameters.createUpdateServerDto was null or undefined when calling updateServer."
      );
    }
  }

  /**
   */
  private updateServerContext(requestParameters: UpdateServerRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: CreateUpdateServerDtoToJSON(requestParameters.createUpdateServerDto)
    };
  }

  /**
   */
  updateServer = async (id: number, createUpdateServerDto: CreateUpdateServerDto): Promise<Server> => {
    const response = await this.updateServerRaw({ id: id, createUpdateServerDto: createUpdateServerDto });
    return await response.value();
  };

  /**
   */
  private async updateServerCredentialsRaw(
    requestParameters: UpdateServerCredentialsRequest
  ): Promise<runtime.ApiResponse<ServerCredentialsCollection>> {
    this.updateServerCredentialsValidation(requestParameters);
    const context = this.updateServerCredentialsContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ServerCredentialsCollectionFromJSON(jsonValue));
  }

  /**
   */
  private updateServerCredentialsValidation(requestParameters: UpdateServerCredentialsRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateServerCredentials."
      );
    }
    if (
      requestParameters.serverCredentialsCollection === null ||
      requestParameters.serverCredentialsCollection === undefined
    ) {
      throw new runtime.RequiredError(
        "serverCredentialsCollection",
        "Required parameter requestParameters.serverCredentialsCollection was null or undefined when calling updateServerCredentials."
      );
    }
  }

  /**
   */
  private updateServerCredentialsContext(requestParameters: UpdateServerCredentialsRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/credentials`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: ServerCredentialsCollectionToJSON(requestParameters.serverCredentialsCollection)
    };
  }

  /**
   */
  updateServerCredentials = async (
    id: number,
    serverCredentialsCollection: ServerCredentialsCollection
  ): Promise<ServerCredentialsCollection> => {
    const response = await this.updateServerCredentialsRaw({
      id: id,
      serverCredentialsCollection: serverCredentialsCollection
    });
    return await response.value();
  };

  /**
   */
  private async updateServerTariffRaw(
    requestParameters: UpdateServerTariffRequest
  ): Promise<runtime.ApiResponse<Server>> {
    this.updateServerTariffValidation(requestParameters);
    const context = this.updateServerTariffContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => ServerFromJSON(jsonValue));
  }

  /**
   */
  private updateServerTariffValidation(requestParameters: UpdateServerTariffRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateServerTariff."
      );
    }
    if (requestParameters.updateServerTariffDto === null || requestParameters.updateServerTariffDto === undefined) {
      throw new runtime.RequiredError(
        "updateServerTariffDto",
        "Required parameter requestParameters.updateServerTariffDto was null or undefined when calling updateServerTariff."
      );
    }
  }

  /**
   */
  private updateServerTariffContext(requestParameters: UpdateServerTariffRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/api/admin/dcim/server/{id}/tariff`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateServerTariffDtoToJSON(requestParameters.updateServerTariffDto)
    };
  }

  /**
   */
  updateServerTariff = async (id: number, updateServerTariffDto: UpdateServerTariffDto): Promise<Server> => {
    const response = await this.updateServerTariffRaw({ id: id, updateServerTariffDto: updateServerTariffDto });
    return await response.value();
  };
}

/**
 * @export
 * @enum {string}
 */
export enum ServersTypeEnum {
  SWITCH = "SWITCH",
  SERVER = "SERVER",
  CUSTOMERHYPERVISOR = "CUSTOMER_HYPERVISOR",
  CUSTOMERSERVER = "CUSTOMER_SERVER"
}
